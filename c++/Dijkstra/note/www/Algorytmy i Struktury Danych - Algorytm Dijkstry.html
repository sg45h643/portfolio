<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
<meta http-equiv="Content-Language" content="pl">
<title>Algorytmy i Struktury Danych - Algorytm Dijkstry</title>
<meta name="description" content="Artyku³ opisuje ró¿ne algorytmy wyszukuj±ce informacje w zbiorach danych takich jak przedzia³y liczbowe, tablice, macierze, wektory, listy, drzewa, grafy, teksty itp.">
<meta name="keywords" content="wyszukiwanie, algorytm, programowanie, c++, pascal, basic, informatyka, liceum, matura, olimpiada, matematyka">
<link rel="stylesheet" type="text/css" href="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/001.css">
<script type="text/javascript" language="javascript" src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/h.js"></script>
<!-- base href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0138.php" -->
</head>

<body>

<table style="border-collapse: collapse" width="100%" border="0" cellpadding="0">
  <tbody><tr>
    <td style="text-align: left" class="menu_l" valign="top" width="164"><a href="http://www.i-lo.tarnow.pl/"><img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/i-lo_logo.gif" style="margin-top: 12px" alt="Do strony g³ównej I LO w Tarnowie" width="164" border="0" height="170"></a></td>
    <td style="text-align: center" class="menu_m" valign="top" nowrap="nowrap">
    <a class="exit" href="http://edu.i-lo.tarnow.pl/inf/index.php"><span>Wyj¶cie </span></a><a class="cont" href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/index.php"><span>Spis tre¶ci </span></a><a class="prev" href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0137.php"><span>Poprzedni </span></a><a class="next" href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0138a.php"><span>Nastêpny </span></a>
<p><img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_title.jpg" alt="tytu³" width="511" border="0" height="195"></p>
    <span class="small">Prezentowane materia³y s± przeznaczone dla uczniów szkó³ ponadgimnazjalnych</span>.<br>
    Autor artyku³u: mgr Jerzy Wa³aszek,&nbsp; wersja 2.0</td>
    <td style="padding:8px; text-align: center" class="menu_r" valign="top" nowrap="nowrap" width="200">
    <p class="small" style="line-height: 100%; margin-bottom: 0">&nbsp;&#169;2014 mgr Jerzy Wa³aszek<br>
    I LO w Tarnowie</p>
    <p><img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_logo.gif" alt="logo" width="134" border="0" height="102"></p>
    </td>
  </tr>
  </tbody></table>
<h1 class="sb1">Najkrótsza ¶cie¿ka w grafie wa¿onym<br>
Algorytm Dijkstry</h1>
<hr size="1" color="#336699">
<table style="border-collapse: collapse" class="sb1" id="table248" border="0" cellpadding="4" cellspacing="0">
	<tbody><tr>
		<td bgcolor="#CCCCCC"><b>Tematy pokrewne</b></td>
<td bgcolor="#CCCCCC">&nbsp;</td>
</tr>
	<tr>
		<td valign="top"><b><a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0122.php">Grafy</a></b><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0123.php">Podstawowe pojêcia dotycz±ce grafów</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0124.php">Reprezentacja grafów w komputerze</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0125.php">Przechodzenie grafów w g³±b &#8211; DFS</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0126.php">Przechodzenie grafów wszerz &#8211; BFS</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0126a.php">Transpozycja grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0126b.php">Kwadrat grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0126c.php">Graf krawêdziowy</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0126d.php">Stopieñ grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0127.php">Znajdowanie ¶cie¿ki w grafie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0128.php">Znajdowanie drogi w labiryncie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0128a.php">Spójno¶æ grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0129.php">Znajdowanie spójnych sk³adowych w grafie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0129a.php">Znajdowanie silnie spójnych 
					sk³adowych w grafie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0130.php">Drzewa rozpinaj±ce grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0130a.php">Znajdowanie mostów w grafie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0130b.php">Znajdowanie punktów artykulacji w grafie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0131.php">Grafy dwudzielne</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0131a.php">Kojarzenie ma³¿eñstw</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0132.php">Cykliczno¶æ grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0133.php">Znajdowanie cykli w grafie</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0134.php">Istnienie cyklu lub ¶cie¿ki Eulera</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0135.php">Znajdowanie cyklu lub ¶cie¿ki Eulera</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0136.php">Znajdowanie cyklu lub ¶cie¿ki 
					Hamiltona</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0137.php">Sortowanie topologiczne grafu 
					skierowanego</a><br>
		<font color="#FF0000"><b>Najkrótsza ¶cie¿ka w grafie wa¿onym &#8211; 
					algorytm Dijkstry</b></font><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0138a.php">Najkrótsza ¶cie¿ka w grafie wa¿onym &#8211; 
					algorytm Bellmana-Forda</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0138b.php">Najkrótsze ¶cie¿ki pomiêdzy 
					wszystkimi parami wierzcho³ków w grafie wa¿onym</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0139.php">Problem chiñskiego listonosza</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0140.php">Problem komiwoja¿era</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0141.php">Minimalne drzewo rozpinaj±ce</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0142.php">Kolorowanie grafu</a><br>
		<a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0143.php">Znajdowanie klik w grafie</a></td>
		<td valign="top">&nbsp;</td>
	</tr>
</tbody></table>
<div class="bl2">
  <p class="mlink">&nbsp;</p></div>
<div class="bl1">
<h3>Problem</h3>
<p class="bl2">W spójnym <a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0123.php#wagi">grafie wa¿onym</a> znale¼æ 
najkrótsze ¶cie¿ki od wybranego wierzcho³ka startowego do wszystkich pozosta³ych 
wierzcho³ków.</p>
<p class="bl2">&nbsp;</p>
<p class="bl2">&nbsp;</p>
<div class="sb1">
		<p>Jednym z podstawowych problemów w teorii grafów jest znajdowanie 
		po³±czeñ pomiêdzy dwoma wybranymi wierzcho³kami. ¦cie¿k±
		<span class="rem">(ang. path)</span> nazywamy uporz±dkowany zbiór 
		wierzcho³ków, które musimy kolejno przej¶æ, aby dotrzeæ w grafie od 
		jednego wybranego wierzcho³ka do innego wybranego wierzcho³ka. ¦cie¿ek 
		takich mo¿e byæ kilka <span class="rem">(lub mo¿e nie istnieæ ¿adna - 
		wtedy wierzcho³ki nazywamy izolowanymi)</span>.</p>
		<p>&nbsp;</p>
		<table id="table1" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
			<tbody><tr>
				<td>
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_01.gif" width="172" border="0" height="186"></td>
				<td>Od wierzcho³ka <font color="#FF0000"><b>0</b></font> do 
				wierzcho³ka <font color="#009900"><b>4</b></font><br>
				mo¿na doj¶æ wieloma ró¿nymi<br>
				¶cie¿kami:<p>¶cie¿ka nr 1: <font color="#FF0000"><b>&nbsp;0</b></font> &#8211;
				<b>3</b> &#8211; <font color="#009900"><b>4</b></font><br>
				¶cie¿ka nr 2: <b><font color="#FF0000">&nbsp;0</font></b> &#8211; <b>
				1</b> &#8211; <b>3</b> &#8211; <font color="#009900"><b>4</b></font><br>
				¶cie¿ka nr 3: <b><font color="#FF0000">&nbsp;0</font></b> &#8211; <b>
				1</b> &#8211; <b>2</b> &#8211; <b>3</b> &#8211;
				<font color="#009900"><b>4</b></font><br>
				¶cie¿ka nr 4: <b><font color="#FF0000">&nbsp;0</font></b> &#8211; <b>
				1</b> &#8211; <b>2</b> &#8211; <font color="#009900"><b>4</b></font><br>
				&nbsp;</p></td>
			</tr>
		</tbody></table>
		<p>&nbsp;</p>
		<p>Je¶li z krawêdziami grafu zwi±zane s± <span class="b">wagi</span>, to 
		ka¿da ze ¶cie¿ek posiada swój <span class="b">koszt</span> przej¶cia 
		równy sumie wag krawêdzi ³±cz±cych poszczególne wierzcho³ki ¶cie¿ki. Dla 
		podanego wy¿ej grafu ¶cie¿ki od wierzcho³ka 0 do 4 maj± nastêpuj±cy 
		koszt:</p>
		<blockquote>
			<p>¶cie¿ka nr 1 - koszt = 3 + 3 = 6<br>
			¶cie¿ka nr 2 - koszt = 3 + 6 + 3 = 12<br>
			¶cie¿ka nr 3 - koszt = 3 + 1 + 5 + 3&nbsp; = 12<br>
			¶cie¿ka nr 4 - koszt = 3 + 1 + 1 = 5</p>
		</blockquote>
		<p>Przez najkrótsz± ¶cie¿kê <span class="rem">(ang. shortest path)</span> 
		³±cz±c± w grafie dwa wybrane wierzcho³ki bêdziemy rozumieli ¶cie¿kê o 
		najmniejszym koszcie przej¶cia, czyli o najmniejszej sumie wag 
		tworz±cych tê ¶cie¿kê krawêdzi.</p>
		<p>&nbsp;</p>
		<table id="table2" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
			<tbody><tr>
				<td>
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_02.gif" width="172" border="0" height="186"></td>
				<td>Od wierzcho³ka <font color="#FF0000"><b>0</b></font> do 
				wierzcho³ka <font color="#009900"><b>4</b></font><br>
				najkrótsz± ¶cie¿k± jest<p><font color="#C0C0C0">¶cie¿ka nr 1: <b>
				&nbsp;0</b> &#8211; <b>3</b> &#8211; <b>4</b><br>
				¶cie¿ka nr 2: </font><b><font color="#C0C0C0">&nbsp;0</font></b><font color="#C0C0C0"> &#8211;
				<b>1</b> &#8211; <b>3</b> &#8211; <b>4</b><br>
				¶cie¿ka nr 3: </font><b><font color="#C0C0C0">&nbsp;0</font></b><font color="#C0C0C0"> &#8211;
				<b>1</b> &#8211; <b>2</b> &#8211; <b>3</b> &#8211; <b>4</b></font><br>
				¶cie¿ka nr 4: <b><font color="#FF0000">&nbsp;0</font></b> &#8211; <b>
				1</b> &#8211; <b>2</b> &#8211; <font color="#009900"><b>4</b></font></p>
				<p>o koszcie przej¶cia równym 5.</p></td>
			</tr>
		</tbody></table>
		<p>&nbsp;</p>
		<p>Je¶li wagi krawêdzi s± nieujemne, to problem znalezienia ¶cie¿ki o 
		najni¿szym koszcie doj¶cia elegancko rozwi±zuje algorytm
		<a target="_blank" href="http://pl.wikipedia.org/wiki/Edsger_Dijkstra">
		Dijkstry</a>. Algorytm ten pozwala znale¼æ koszty doj¶cia od wierzcho³ka 
		startowego v do ka¿dego innego wierzcho³ka w grafie <span class="rem">(o 
		ile istnieje odpowiednia ¶cie¿ka)</span>. Dodatkowo wyznacza on 
		poszczególne ¶cie¿ki. Zasada pracy jest nastêpuj±ca:</p>
		<p>&nbsp;</p><div class="bl1">Tworzymy dwa zbiory wierzcho³ków Q i S. 
			Pocz±tkowo zbiór <i>Q</i> zawiera wszystkie wierzcho³ki grafu, a 
			zbiór <i>S</i> jest pusty. Dla wszystkich wierzcho³ków <i>u</i> 
			grafu za wyj±tkiem startowego <i>v</i> ustawiamy koszt doj¶cia d(<i>u</i>) 
			na nieskoñczono¶æ. Koszt doj¶cia d(<i>v</i>) zerujemy. Dodatkowo 
			ustawiamy poprzednik p(<i>u</i>) ka¿dego wierzcho³ka <i>u</i> grafu 
			na niezdefiniowany. Poprzedniki bêd± wyznacza³y w kierunku odwrotnym 
			najkrótsze ¶cie¿ki od wierzcho³ków <i>u</i> do wierzcho³ka 
			startowego <i>v</i>. Teraz w pêtli dopóki zbiór <i>Q</i> zawiera 
			wierzcho³ki, wykonujemy nastêpuj±ce czynno¶ci:<ol>
				<li>Wybieramy ze zbioru <i>Q</i> wierzcho³ek <i>u</i> o 
				najmniejszym koszcie doj¶cia d(<i>u</i>).</li>
				<li>Wybrany wierzcho³ek <i>u</i> usuwamy ze zbioru <i>Q</i> i 
				dodajemy do zbioru <i>S</i>.</li>
				<li>Dla ka¿dego s±siada <i>w</i> wierzcho³ka <i>u</i>, który 
				jest wci±¿ w zbiorze <i>Q</i>, sprawdzamy, czy d(<i>w</i>) &gt; d(<i>u</i>) 
				+ waga krawêdzi <i>u&#8211;w</i>. Je¶li tak, to wyznaczamy nowy 
				koszt doj¶cia do wierzcho³ka <i>w</i> jako: d(<i>w</i>) &#8592; 
				d(<i>u</i>) + waga krawêdzi <i>u&#8211;w</i>. Nastêpnie 
				wierzcho³ek <i>u</i> czynimy poprzednikiem <i>w</i>: p(<i>w</i>) &#8592;
				<i>u</i>.</li>
			</ol>
		</div>
		<p>Aby lepiej zrozumieæ zasadê dzia³ania algorytmu Dijkstry, prze¶led¼my 
		jego kolejne kroki w poni¿szej tabelce:</p>
		<p>&nbsp;</p>
		<table id="table4" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
			<tbody><tr>
				<td valign="top" align="center">
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_03.gif" width="218" border="0" height="171"></td>
				<td>&nbsp;</td>
				<td>Mamy wa¿ony graf skierowany z wierzcho³kiem startowym v = 0. 
				Bêdziemy wyznaczaæ najni¿sze koszty doj¶cia od wyró¿nionego 
				wierzcho³ka do wszystkich pozosta³ych wierzcho³ków w grafie oraz 
				najkrótsze ¶cie¿ki pomiêdzy wyró¿nionym wierzcho³kiem, a 
				wszystkimi pozosta³ymi.</td>
			</tr>
			<tr>
				<td valign="top" align="center">
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_04.gif" width="282" border="0" height="201"></td>
				<td>&nbsp;</td>
				<td>Tworzymy dwa zbiory <i>S</i> i <i>Q</i>. Zbiór <i>S</i> jest 
				pocz±tkowo pusty, a zbiór <i>Q</i> obejmuje wszystkie 
				wierzcho³ki grafu. W zbiorze <i>S</i> znajd± siê wierzcho³ki 
				przetworzone przez algorytm Dijkstry, a w zbiorze <i>Q</i> bêd± 
				wierzcho³ki wci±¿ czekaj±ce na przetworzenie.</td>
			</tr>
			<tr>
				<td valign="top" align="center">
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_05.gif" width="282" border="0" height="201"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">1</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">2</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">3</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">4</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
					</tr>
				</tbody></table>
				</td>
				<td>Tworzymy dwie tablice <i>d</i> i <i>p</i> o <i>n</i> elementach, gdzie n 
				oznacza liczbê wierzcho³ków w grafie.<p>Elementy tablicy <i>d</i> 
				bêd± zawiera³y minimalne koszty doj¶cia do poszczególnych 
				wierzcho³ków z wierzcho³ka startowego. Pocz±tkowo w elementach
				<i>d</i> umieszczamy warto¶æ +nieskoñczono¶æ. W elemencie <i>d</i>[<i>v</i>] 
				umieszczamy zero.</p>
				<p>Elementy tablicy <i>p</i> bêd± przechowywa³y numery 
				wierzcho³ków-poprzedników na ¶cie¿ce od wierzcho³ka v. Id±c 
				wstecz po tych numerach dotrzemy do wierzcho³ka startowego. We 
				wszystkich elementach tablicy <i>p</i> umieszczamy warto¶æ, która nie 
				mo¿e oznaczaæ numeru wierzcho³ka, np. -1.</p></td>
			</tr>
			<tr>
				<td valign="top" align="center">
				&nbsp;<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_06.gif" width="268" border="0" height="201"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">1</font></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">2</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">3</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">4</font></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000"><b>3</b></font></td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000"><b>3</b></font></td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000"><b><span lang="en">&nbsp;</span>0</b></font></td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000"><b><span lang="en">&nbsp;</span>0</b></font></td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
					</tr>
				</tbody></table>
				</td>
				<td>W zbiorze <i>Q</i> szukamy wierzcho³ka <i>u</i> o najmniejszym 
				koszcie doj¶cia <i>d</i>[<i>u</i>]. Oczywi¶cie, jest to wierzcho³ek 
				startowy 0, dla którego <i>d</i>[0] = 0. Wierzcho³ek 0 przenosimy ze 
				zbioru <i>Q</i> do <i>S</i>. Nastêpnie przegl±damy wszystkich s±siadów 
				przeniesionego wierzcho³ka &#8211; tutaj s± to wierzcho³ki 1 i 
				4. Sprawdzamy, czy:<p><i>d</i>[1] &gt; <i>d</i>[0] + 3 ? &#8211; TAK, zatem 
				<i>d</i>[1] &#8592; 
				<i>d</i>[0] + 3 = 3. Do <i>p</i>[1] wpisujemy 0, czyli poprzednik na ¶cie¿ce.</p>
				<p><i>d</i>[4] &gt; <i>d</i>[0] + 3 ? &#8211; TAK, zatem <i>d</i>[4] &#8592; 
				<i>d</i>[0] + 3 = 3. 
				Do <i>p</i>[4] wpisujemy 0, czyli poprzednik na ¶cie¿ce.</p></td>
			</tr>
			<tr>
				<td valign="top" align="center">
				&nbsp;<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_07.gif" width="270" border="0" height="183"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">1</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">2</font></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">3</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">4</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00"><b>
						<font color="#FF0000">4</font></b></td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">&nbsp;<b>1</b></font></td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
					</tr>
				</tbody></table>
				</td>
				<td>Ponownie w zbiorze <i>Q</i> szukamy wierzcho³ka <i>u</i> o 
				najmniejszym koszcie doj¶cia <i>d</i>[<i>u</i>]. S± dwa takie 
				wierzcho³ki: 1 i 4 <span class="rem">(<i>d</i>[1] = 3 i <i>d</i>[4] = 3)</span>. 
				Wybieramy dowolny z nich, niech bêdzie to wierzcho³ek 1. 
				Przenosimy go do zbioru <i>S</i> i sprawdzamy s±siada 2:<p><i>d</i>[2] 
				&gt; <i>d</i>[1] + 1 ? &#8211; TAK, zatem <i>d</i>[2] &#8592; <i>d</i>[1] + 1 = 4. Do 
				<i>p</i>[2] wpisujemy 
				1, czyli poprzednik na ¶cie¿ce.</p></td>
			</tr>
			<tr>
				<td valign="top" align="center">
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_08.gif" width="263" border="0" height="185"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">1</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">2</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">3</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">4</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">5</font></td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
						<td style="text-align: right" nowrap="nowrap">&#8734;</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00"><b>
						<font color="#FF0000">5</font></b></td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">&nbsp;1</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00"><b>
						<font color="#FF0000">4</font></b></td>
					</tr>
				</tbody></table>
				</td>
				<td>Kolejnym wierzcho³kiem <i>u</i> w zbiorze <i>Q</i> o 
				najni¿szym koszcie doj¶cia <i>d</i>[<i>u</i>] jest wierzcho³ek 4
				<span class="rem">(<i>d</i>[4] = 3)</span>. Przenosimy go do zbioru <i>
				S</i>, a nastêpnie sprawdzamy koszt doj¶cia do jego s±siada, 
				wierzcho³ka 5:<p><i>d</i>[5] &gt; <i>d</i>[4] + 2 ? &#8211; TAK, zatem 
				<i>d</i>[5] &#8592; <i>d</i>[4] + 2 
				= 5. Do <i>p</i>[5] wpisujemy 4, czyli poprzednik na ¶cie¿ce.</p></td>
			</tr>
			<tr>
				<td valign="top" align="center">
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_09.gif" width="259" border="0" height="186"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">1</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">2</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">3</font></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">4</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00"><b>
						<font color="#FF0000">7</font></b></td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">&nbsp;1</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00"><b>
						<font color="#FF0000">&nbsp;2</font></b></td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
					</tr>
				</tbody></table>
				</td>
				<td>Teraz ze zbioru Q przenosimy do <i>S</i> wierzcho³ek 2
				<span class="rem">(<i>d</i>[2] = 4)</span>. Wierzcho³ek ten posiada w 
				zbiorze Q dwóch s±siadów: 3 i 5. Sprawdzamy ich koszty doj¶cia:<p>
				<i>d</i>[3] &gt; <i>d</i>[2] + 3 ? &#8211; TAK, zatem <i>d</i>[3] &#8592; 
				<i>d</i>[2] + 3 = 7. Do <i>p</i>[3] 
				wpisujemy 2, czyli poprzednik na ¶cie¿ce.</p>
				<p><i>d</i>[5] &gt; <i>d</i>[2] + 1 ? &#8211; NIE, nic dalej nie robimy z tym 
				wierzcho³kiem</p></td>
			</tr>
			<tr>
				<td valign="top" align="center">
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_10.gif" width="264" border="0" height="181"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">1</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">2</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000">3</font></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">4</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00">
						<font color="#FF0000"><b>6</b></font></td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">&nbsp;1</td>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#FFCC00"><b>
						<font color="#FF0000">&nbsp;5</font></b></td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
					</tr>
				</tbody></table>
				</td>
				<td>Do zbioru <i>S</i> przenosimy wierzcho³ek 5 <span class="rem">(<i>d</i>[5] 
				= 5)</span>. W zbiorze <i>Q</i> ma on tylko jednego s±siada, 
				wierzcho³ek 3. Sprawdzamy koszt doj¶cia do wierzcho³ka 3:<p><i>d</i>[3] 
				&gt; <i>d</i>[5] + 1 ? &#8211; TAK, zatem <i>d</i>[3] &#8592; <i>d</i>[5] + 1 = 6. Do 
				<i>p</i>[3] wpisujemy 
				5, czyli poprzednik na ¶cie¿ce.</p><p>Zwróæ uwagê, ¿e w tym 
				przypadku algorytm znalaz³ lepsz± ¶cie¿kê do wierzcho³ka 3 o 
				ni¿szym koszcie.</p></td>
			</tr>
			<tr>
				<td valign="top" align="center">
				<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_11.gif" width="276" border="0" height="177"></td>
				<td>
				<table style="border-collapse: collapse" border="1" bordercolor="#C0C0C0" cellpadding="2">
					<tbody><tr>
						<td style="text-align: right" nowrap="nowrap" bgcolor="#F0F0F0">
						<i>u</i></td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">0</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">1</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">2</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">
						3</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">4</td>
						<td style="text-align: right" class="small" nowrap="nowrap" bgcolor="#F0F0F0">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>d</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">0</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
						<td style="text-align: right" nowrap="nowrap">6</td>
						<td style="text-align: right" nowrap="nowrap">
						3</td>
						<td style="text-align: right" nowrap="nowrap">5</td>
					</tr>
					<tr>
						<td nowrap="nowrap" bgcolor="#F0F0F0"><i>p</i>[<i>u</i>]</td>
						<td style="text-align: right" nowrap="nowrap">-1</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">&nbsp;1</td>
						<td style="text-align: right" nowrap="nowrap">&nbsp;5</td>
						<td style="text-align: right" nowrap="nowrap">
						<span lang="en">&nbsp;</span>0</td>
						<td style="text-align: right" nowrap="nowrap">4</td>
					</tr>
				</tbody></table>
				</td>
				<td>Do zbioru S przenosimy ostatni wierzcho³ek 3. Zbiór Q sta³ 
				siê pusty, zatem przeniesiony wierzcho³ek nie ma w zbiorze Q 
				¿adnych s±siadów. Algorytm koñczy siê. W tablicy <i>d</i> mamy 
				policzone koszty doj¶cia do ka¿dego z wierzcho³ków grafu. W 
				tablicy <i>p</i> znajduj± siê poprzedniki na ¶cie¿ce ka¿dego 
				wierzcho³ka, co pozwala odtworzyæ ¶cie¿ki do poszczególnych 
				wierzcho³ków grafu: idziemy wstecz po kolejnych poprzednikach, 
				a¿ dojdziemy do wierzcho³ka startowego, dla którego nie istnieje 
				poprzednik <span class="rem">(warto¶æ -1)</span>.</td>
			</tr>
		</tbody></table>
		<p>&nbsp;</p>
		<p>Z tablic <i>d</i> i <i>p</i> odczytujemy:</p>
		<ul>
			<li>Doj¶cie do wierzcho³ka 0: ¶cie¿ka pusta, koszt 0</li>
			<li>Doj¶cie do wierzcho³ka 1: 0&#8211;1, koszt 3</li>
			<li>Doj¶cie do wierzcho³ka 2: 0&#8211;1&#8211;2, koszt 4</li>
			<li>Doj¶cie do wierzcho³ka 3: 0&#8211;4&#8211;5&#8211;3, koszt 6</li>
			<li>Doj¶cie do wierzcho³ka 4: 0&#8211;4, koszt 3</li>
			<li>Doj¶cie do wierzcho³ka 5: 0&#8211;4&#8211;5, koszt 5</li>
		</ul>
		<p>&nbsp;</p>
	<h4><a name="A1"></a>Algorytm Dijkstry obliczania najkrótszych ¶cie¿ek i 
	kosztów doj¶cia w grafie wa¿onym &#8211; wersja pogl±dowa</h4>
	<h5>Wej¶cie</h5>
	<div class="sb1">
		<table id="table282" style="BORDER-COLLAPSE: collapse" border="0" cellpadding="2">
			<tbody><tr>
				<td valign="top" nowrap="nowrap"><i>n</i></td>
				<td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td>liczba wierzcho³ków w grafie, <i>n</i>
					<img alt="symbol" src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_symbol_05.gif" width="8" border="0" height="8">
					<span class="f">C</span></td>
			</tr>
			<tr>
				<td valign="top" nowrap="nowrap"><i>graf</i></td>
				<td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td>zadany w dowolnie wybrany sposób, algorytm tego nie 
				precyzuje. Definicja grafu powinna udostêpniaæ wagi krawêdzi.</td>
			</tr>
			<tr>
				<td valign="top" nowrap="nowrap">v</td>
				<td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td>wierzcho³ek startowy, <i>v</i>
					<img alt="symbol" src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_symbol_05.gif" width="8" border="0" height="8">
					<span class="f">C</span></td>
			</tr>
		</tbody></table></div>
	<h5>Wyj¶cie:</h5>
	<div class="sb1">
		<table id="table13" style="border-collapse: collapse" border="0" cellpadding="2">
			<tbody><tr>
				<td valign="top" nowrap="nowrap"><i>d</i></td>
				<td valign="top" nowrap="nowrap">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td valign="top"><i>n</i> elementowa tablica z kosztami doj¶cia 
				od wierzcho³ka v do wierzcho³ka <i>i</i>-tego wzd³u¿ najkrótszej 
				¶cie¿ki. Koszt doj¶cia jest sum± wag krawêdzi, przez które 
				przechodzimy posuwaj±c siê wzd³u¿ wyznaczonej najkrótszej 
				¶cie¿ki.</td>
			</tr>
			<tr>
				<td valign="top" nowrap="nowrap"><i>p</i></td>
				<td valign="top" nowrap="nowrap">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td valign="top"><i>n</i> elementowa tablica z poprzednikami 
				wierzcho³ków na wyznaczonej najkrótszej ¶cie¿ce. Dla <i>i</i>-tego 
				wierzcho³ka grafu <i>p</i>[i] zawiera numer wierzcho³ka poprzedzaj±cego 
				na najkrótszej ¶cie¿ce</td>
			</tr>
		</tbody></table>
		</div>
	<h5>Elementy pomocnicze:</h5>
	<div class="sb1">
		<table id="table280" style="BORDER-COLLAPSE: collapse" border="0" cellpadding="2">
			<tbody><tr>
				<td valign="top" nowrap="nowrap"><i>S</i></td>
				<td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td>zbiór wierzcho³ków grafu o policzonych ju¿ najkrótszych 
				¶cie¿kach od wybranego wierzcho³ka <i>v</i></td>
			</tr>
			<tr>
				<td valign="top" nowrap="nowrap"><i>Q</i></td>
				<td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td>zbiór wierzcho³ków grafu, dla których najkrótsze ¶cie¿ki nie 
				zosta³y jeszcze policzone</td>
			</tr>
			<tr>
				<td valign="top" nowrap="nowrap"><i>u,w</i></td>
				<td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
				<td>wierzcho³ki, <i>u,w</i>
					<img alt="symbol" src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_symbol_05.gif" width="8" border="0" height="8">
					<span class="f">C</span></td>
			</tr>
			</tbody></table></div>
	<h5><a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
	<div class="bl1">
		<table style="border-collapse: collapse" id="table281" border="0" cellpadding="2">
			<tbody><tr>
				<td valign="top">K01:</td>
				<td valign="top" nowrap="nowrap"><i>S</i> &#8592; &#216;</td>
				<td class="c" valign="top">; zbiór S ustawiamy jako pusty</td>
			</tr>
			<tr>
				<td valign="top">K02:</td>
				<td valign="top" nowrap="nowrap"><i>Q</i> &#8592; wszystkie wierzcho³ki 
				grafu</td>
				<td class="c" valign="top">&nbsp;</td>
			</tr>
			<tr>
				<td valign="top">K03:</td>
				<td valign="top" nowrap="nowrap">Utwórz <i>n</i> elementow± tablicê <i>d</i></td>
				<td class="c" valign="top">; tablica na koszty doj¶cia</td>
			</tr>
			<tr>
				<td valign="top">K04:</td>
				<td valign="top" nowrap="nowrap">Utwórz <i>n</i> elementow± tablicê <i>p</i></td>
				<td class="c" valign="top">; tablica poprzedników na ¶cie¿kach</td>
			</tr>
			<tr>
				<td valign="top">K05</td>
				<td valign="top" nowrap="nowrap">Tablicê <i>d</i> wype³nij najwiêksz± 
				warto¶ci± dodatni±</td>
				<td class="c" valign="top">&nbsp;</td>
			</tr>
			<tr>
				<td valign="top">K06:</td>
				<td valign="top" nowrap="nowrap"><i>d</i>[<i>v</i>] &#8592; 0</td>
				<td class="c" valign="top">; koszt doj¶cia do samego siebie jest 
				zawsze zerowy</td>
			</tr>
			<tr>
				<td valign="top">K07:</td>
				<td valign="top" nowrap="nowrap">Tablicê <i>p</i> wype³nij warto¶ciami -1</td>
				<td class="c" valign="top">; -1 oznacza brak poprzednika</td>
			</tr>
			<tr>
				<td valign="top">K08:</td>
				<td valign="top" nowrap="nowrap"><b>Dopóki</b> <i>Q</i> zawiera 
				wierzcho³ki, <b>wykonuj</b> K09...K12</td>
				<td class="c" valign="top">&nbsp;</td>
			</tr>
			<tr>
				<td valign="top">K09:</td>
				<td valign="top" nowrap="nowrap">&nbsp;&nbsp;&nbsp; Z <i>Q</i> do <i>S</i> 
				przenie¶ wierzcho³ek <i>u</i> o najmniejszym <i>d</i>[<i>u</i>]</td>
				<td class="c" valign="top">&nbsp;</td>
			</tr>
			<tr>
				<td valign="top">K10:</td>
				<td valign="top" nowrap="nowrap">&nbsp;&nbsp;&nbsp; <b>Dla</b> ka¿dego 
				s±siada <i>w</i> wierzcho³ka <i>u</i>, <b>wykonuj</b> K11...K12</td>
				<td class="c" valign="top">; przegl±damy s±siadów przeniesionego 
				wierzcho³ka </td>
			</tr>
			<tr>
				<td valign="top">K11:</td>
				<td valign="top" nowrap="nowrap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<b>Je¶li</b> <i>w</i> nie jest w <i>Q</i>, <b>to nastêpny obieg 
				pêtli</b> K10</td>
				<td class="c" valign="top">; szukamy s±siadów obecnych w Q</td>
			</tr>
			<tr>
				<td valign="top">K12:</td>
				<td valign="top" nowrap="nowrap">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<b>Je¶li</b> <i>d</i>[<i>w</i>] &gt; <i>d</i>[<i>u</i>] + waga 
				krawêdzi <i>u&#8211;w</i>, <b>to</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>d</i>[<i>w</i>] &#8592;
				<i>d</i>[<i>u</i>] + waga krawêdzi <i>u&#8211;w</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>p</i>[<i>w</i>] &#8592;
				<i>u</i></td>
				<td class="c" valign="top">; sprawdzamy koszt doj¶cia<br>
				; je¶li mamy ni¿szy, to modyfikujemy koszt<br>
				; i zmieniamy poprzednika w na u</td>
			</tr>
			<tr>
				<td valign="top">K13:</td>
				<td valign="top" nowrap="nowrap"><b>Zakoñcz</b></td>
				<td class="c" valign="top">&nbsp;</td>
			</tr>
			</tbody></table></div>
		<p>&nbsp;</p>
		<p>Aby efektywnie zaimplementowaæ <span class="b">algorytm Dijkstry</span>, 
		musimy najpierw rozwi±zaæ kilka problemów.</p>
		<p>Pierwszym z nich jest sposób reprezentacji grafu w pamiêci komputera. 
		Poniewa¿ algorytm czêsto bêdzie odwo³ywa³ siê do wierzcho³ków 
		s±siaduj±cych z wierzcho³kiem przetwarzanym <span class="rem">(tzn. 
		po³±czonych z nim krawêdzi±)</span>, to reprezentacja grafu powinna 
		efektywnie umo¿liwiaæ szybkie wyszukiwanie s±siadów. Warunek ten 
		spe³niaj± <a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0124.php#P4">listy s±siedztwa</a>.</p>
		<p>Drugim problemem jest sposób reprezentacji zbiorów <i>S</i> i <i>Q</i>. 
		Zbiory te s± ze sob± powi±zane logicznie. Je¶li wierzcho³ek jest w 
		zbiorze <i>Q</i>, to oczywi¶cie nie ma go w zbiorze <i>S</i> i na 
		odwrót. Utworzymy zatem dodatkow± tablicê logiczn± <i>QS</i>[ ] o
		<span class="f">n</span>-elementach. Indeks bêdzie okre¶la³ wierzcho³ek 
		grafu, natomiast zawarto¶æ false bêdzie oznacza³a, i¿ wierzcho³ek ten 
		jest w <i>Q</i>, a zawarto¶æ true, i¿ jest w <i>S</i>.</p>
		<p>Nastêpny problem, to sprawdzanie, czy zbiór <i>Q</i> jest pusty w 
		warunku kontynuacji pêtli. Zwróæ uwagê, i¿ przy ka¿dym przebiegu tej 
		pêtli dok³adnie jeden wierzcho³ek jest przenoszony z <i>Q</i> do <i>S
		</i><span class="rem">(zmienia swój stan w QS[ ] z false na true)</span>. 
		Zatem po <span class="f">n</span>-tym przebiegu wszystkie wierzcho³ki 
		automatycznie znajd± siê w zbiorze <i>S</i>. Nie musimy sprawdzaæ <i>Q</i> 
		- wystarczy, i¿ pêtlê t± zrealizujemy jako pêtlê iteracyjn± o
		<span class="f">n</span> przebiegach.</p>
		<p>Kolejnym problemem wp³ywaj±cym na efektywno¶æ algorytmu jest 
		wyszukiwanie w zbiorze <i>Q</i> wierzcho³ka o najmniejszej warto¶ci 
		kosztu doj¶cia <i>d</i>. Mo¿emy tutaj zastosowaæ proste wyszukiwanie 
		liniowe - wtedy ca³y algorytm bêdzie mia³ czasow± z³o¿ono¶æ obliczeniow± 
		klasy <i>O</i><span class="f"><span style="font-style: normal">(</span></span><i>n<sup>2</sup></i><span style="font-style: normal"><span class="f">)</span></span>. 
		Jednak¿e du¿o lepszym pomys³em <span class="rem">(ale trudniejszym w 
		realizacji)</span> jest zastosowanie <a href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0106.php">kolejki 
		priorytetowej</a> opartej na strukturze kopca.</p>
		<p>&nbsp;</p>
	<h4>Program</h4>
	<div class="sb1">
		<table style="border-collapse: collapse" border="0" cellpadding="8">
			<tbody><tr>
				<td class="note"><b>Wa¿ne</b>:<br>
				<p class="bl1">Zanim uruchomisz program, przeczytaj 
				<a target="_blank" href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0001.php#konsola">wstêp</a> do tego artyku³u, w którym wyja¶niamy 
      funkcje tych programów oraz sposób korzystania z nich. </p></td>
			</tr>
		</tbody></table>
		<p>&nbsp;</p></div>
	<div class="sb1">
	<p>Poni¿szy program jest przyk³adow± realizacj± 
	algorytmu Dijkstry z wyszukiwaniem liniowym. 
	Definicja danych wej¶ciowych jest nastêpuj±ca:</p>
		<p>&nbsp;</p>
		<div class="bl1">
	<p>W pierwszym wierszu program odczytuje kolejno numer wierzcho³ka startowego v, 
	liczbê wierzcho³ków <i>n</i> oraz liczbê krawêdzi <i>m</i>. W <i>m</i> 
	kolejnych wierszach znajduj± siê definicje krawêdzi. Definicja sk³ada siê z 
	trzech liczb <i>x y w</i>. Pierwsza i druga liczba okre¶la wierzcho³ki grafu, które 
	s± ze sob± po³±czone t± krawêdzi± &#8211; krawêd¼ biegnie od wierzcho³ka <i>x</i> do 
	wierzcho³ka <i>y</i>. Trzecia liczba jest wag± krawêdzi <i>w</i>.</p>
	<p>Na wyj¶ciu program wypisuje znalezione najkrótsze ¶cie¿ki od wierzcho³ka 
	<i>v</i> do wszystkich pozosta³ych wierzcho³ków. Oprócz ¶cie¿ki wypisywany jest 
	równie¿ koszt przej¶cia tej ¶cie¿ki.</p>
			<p>&nbsp;</p>
		</div>
	<p>Przyk³adowe dane:</p>
	<blockquote>
      <table id="table32" style="border-collapse: collapse" border="0" cellpadding="4">
        <tbody><tr>
          <td>
          		<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_03.gif" width="218" border="0" height="171"></td>
          <td>0 6 9<br>
			0 1 3<br>
			0 4 3<br>
			1 2 1<br>
			2 3 3<br>
			2 5 1<br>
			3 1 3<br>
			4 5 2<br>
			5 0 6<br>
			5 3 1</td>
        </tr>
      </tbody></table>
    </blockquote>
    &nbsp;<table id="table257" style="border-collapse: collapse" border="1" bordercolor="#808080" cellpadding="4" cellspacing="0">
			<tbody><tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Lazarus</b></td>
			</tr>
			<tr>
				<td style="text-align: left">
				<pre id="pas"><pre><span class="c">// Algorytm Dijkstry z wyszukiwaniem liniowym</span>
<span class="c">// Data: 15.03.2014</span>
<span class="c">// (C)2014 mgr Jerzy Wa³aszek</span>
<span class="c">//-------------------------------------------</span>

<span class="i">program</span> <span class="v">dijkstra</span>;

<span class="c">// Typy danych</span>

<span class="i">type</span>
  <span class="v">PslistEl</span> = ^<span class="v">slistEl</span>;
  <span class="v">slistEl</span> =  <span class="i">record</span>
    <span class="v">next</span>  : <span class="v">PslistEl</span>;
    <span class="v">v</span>,<span class="v">w</span>   : <span class="v">integer</span>;              <span class="c">// numer wêz³a docelowego i waga krawêdzi</span>
  <span class="i">end</span>;

<span class="c">// **********************</span>
<span class="c">// *** PROGRAM G£ÓWNY ***</span>
<span class="c">// **********************</span>

<span class="i">var</span>
  <span class="v">i</span>,<span class="v">j</span>,<span class="v">m</span>,<span class="v">n</span>,<span class="v">v</span>,<span class="v">u</span>,<span class="v">w</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">sptr</span> : <span class="v">integer</span>;
  <span class="v">d</span>,<span class="v">p</span>,<span class="v">S</span> : <span class="i">array</span> <span class="i">of</span> <span class="v">integer</span>;
  <span class="v">QS</span>    : <span class="i">array</span> <span class="i">of</span> <span class="v">boolean</span>;       <span class="c">// Zbiory Q i S</span>
  <span class="v">graf</span>  : <span class="i">array</span> <span class="i">of</span> <span class="v">PslistEl</span>;      <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">pw</span>,<span class="v">rw</span> : <span class="v">PslistEl</span>;

<span class="i">begin</span>
  <span class="v">read</span>(<span class="v">v</span>,<span class="v">n</span>,<span class="v">m</span>);                    <span class="c">// Wêze³ startowy, liczba wierzcho³ków i krawêdzi</span>

  <span class="c">// Tworzymy tablice dynamiczne</span>

  <span class="v">SetLength</span>(<span class="v">d</span>,<span class="v">n</span>);                 <span class="c">// Tablica kosztów doj¶cia</span>
  <span class="v">SetLength</span>(<span class="v">p</span>,<span class="v">n</span>);                 <span class="c">// Tablica poprzedników</span>
  <span class="v">SetLength</span>(<span class="v">QS</span>,<span class="v">n</span>);                <span class="c">// Zbiory Q i S</span>
  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="v">n</span>);              <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">SetLength</span>(<span class="v">S</span>,<span class="v">n</span>);                 <span class="c">// Stos</span>
  <span class="v">sptr</span> := <span class="n">0</span>;                      <span class="c">// Wska¼nik stosu</span>

  <span class="c">// Inicjujemy tablice dynamiczne</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">d</span>[<span class="v">i</span>] := <span class="v">MAXINT</span>;
    <span class="v">p</span>[<span class="v">i</span>] := -<span class="n">1</span>;
    <span class="v">QS</span>[<span class="v">i</span>] := <span class="v">false</span>;
    <span class="v">graf</span>[<span class="v">i</span>] := <span class="v">nil</span>;
  <span class="i">end</span>;

  <span class="c">// Odczytujemy dane wej¶ciowe</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">1</span> <span class="i">to</span> <span class="v">m</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">read</span>(<span class="v">x</span>,<span class="v">y</span>,<span class="v">w</span>);                  <span class="c">// Odczytujemy krawêd¼ z wag±</span>
    <span class="v">new</span>(<span class="v">pw</span>);                      <span class="c">// Tworzymy element listy s±siedztwa</span>
    <span class="v">pw</span>^.<span class="v">v</span> := <span class="v">y</span>;                   <span class="c">// Wierzcho³ek docelowy krawêdzi</span>
    <span class="v">pw</span>^.<span class="v">w</span> := <span class="v">w</span>;                   <span class="c">// Waga krawêdzi</span>
    <span class="v">pw</span>^.<span class="v">next</span> := <span class="v">graf</span>[<span class="v">x</span>];
    <span class="v">graf</span>[<span class="v">x</span>] := <span class="v">pw</span>;                <span class="c">// Element do³±czamy do listy</span>
  <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="v">d</span>[<span class="v">v</span>] := <span class="n">0</span>;                      <span class="c">// Koszt doj¶cia v jest zerowy</span>

  <span class="c">// Wyznaczamy ¶cie¿ki</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">1</span> <span class="i">to</span> <span class="v">n</span> <span class="i">do</span>
  <span class="i">begin</span>

    <span class="c">// Szukamy wierzcho³ka w Q o najmniejszym koszcie d</span>

    <span class="v">j</span> := <span class="n">0</span>;
    <span class="i">while</span> <span class="v">QS</span>[<span class="v">j</span>] <span class="i">do</span> <span class="v">inc</span>(<span class="v">j</span>);
    <span class="v">u</span> := <span class="v">j</span>;
    <span class="v">inc</span>(<span class="v">j</span>);
    <span class="i">while</span> <span class="v">j</span> &lt; <span class="v">n</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="i">if</span> <span class="i">not</span> <span class="v">QS</span>[<span class="v">j</span>] <span class="i">and</span> (<span class="v">d</span>[<span class="v">j</span>] &lt; <span class="v">d</span>[<span class="v">u</span>]) <span class="i">then</span> <span class="v">u</span> := <span class="v">j</span>;
      <span class="v">inc</span>(<span class="v">j</span>)
    <span class="i">end</span>;

    <span class="c">// Znaleziony wierzcho³ek przenosimy do S</span>

    <span class="v">QS</span>[<span class="v">u</span>] := <span class="v">true</span>;

    <span class="c">// Modyfikujemy odpowiednio wszystkich s±siadów u, którzy s± w Q</span>

    <span class="v">pw</span> := <span class="v">graf</span>[<span class="v">u</span>];
    <span class="i">while</span> <span class="v">pw</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="i">if</span> <span class="i">not</span> <span class="v">QS</span>[<span class="v">pw</span>^.<span class="v">v</span>] <span class="i">and</span> (<span class="v">d</span>[<span class="v">pw</span>^.<span class="v">v</span>] &gt; <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>^.<span class="v">w</span>) <span class="i">then</span>
      <span class="i">begin</span>
        <span class="v">d</span>[<span class="v">pw</span>^.<span class="v">v</span>] := <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>^.<span class="v">w</span>;
        <span class="v">p</span>[<span class="v">pw</span>^.<span class="v">v</span>] := <span class="v">u</span>;
      <span class="i">end</span>;
      <span class="v">pw</span> := <span class="v">pw</span>^.<span class="v">next</span>;
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="c">// Gotowe, wy¶wietlamy wyniki</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">write</span>(<span class="v">i</span>,<span class="t">': '</span>);

    <span class="c">// ¦cie¿kê przechodzimy od koñca ku pocz±tkowi,</span>
    <span class="c">// Zapisuj±c na stosie kolejne wierzcho³ki</span>

    <span class="v">j</span> := <span class="v">i</span>;
    <span class="i">while</span> <span class="v">j</span> &gt; -<span class="n">1</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">S</span>[<span class="v">sptr</span>] := <span class="v">j</span>;
      <span class="v">inc</span>(<span class="v">sptr</span>);
      <span class="v">j</span> := <span class="v">p</span>[<span class="v">j</span>];
    <span class="i">end</span>;

    <span class="c">// Wy¶wietlamy ¶cie¿kê, pobieraj±c wierzcho³ki ze stosu</span>

    <span class="i">while</span> <span class="v">sptr</span> &gt; <span class="n">0</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">dec</span>(<span class="v">sptr</span>);
      <span class="v">write</span>(<span class="v">S</span>[<span class="v">sptr</span>],<span class="t">' '</span>);
    <span class="i">end</span>;

    <span class="c">// Na koñcu ¶cie¿ki wypisujemy jej koszt</span>

    <span class="v">writeln</span>(<span class="t">'$'</span>,<span class="v">d</span>[<span class="v">i</span>]);
  <span class="i">end</span>;

  <span class="c">// Usuwamy tablice dynamiczne</span>

  <span class="v">SetLength</span>(<span class="v">d</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">p</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">QS</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">S</span>,<span class="n">0</span>);

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">pw</span> := <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span> <span class="v">pw</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">rw</span> := <span class="v">pw</span>;
      <span class="v">pw</span> := <span class="v">pw</span>^.<span class="v">next</span>;
      <span class="v">dispose</span>(<span class="v">rw</span>);
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="n">0</span>);
<span class="i">end</span>. </pre></pre>
				</td>
			</tr>
			<tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Code::Blocks</b></td>
			</tr>
			<tr>
				<td style="text-align: left">
				<pre id="cpp"><pre><span class="c">// Algorytm Dijkstry z wyszukiwaniem liniowym</span>
<span class="c">// Data: 15.03.2014</span>
<span class="c">// (C)2014 mgr Jerzy Wa³aszek</span>
<span class="c">//-------------------------------------------</span>

<span class="pp">#include &lt;iostream&gt;</span>

<span class="i">using</span> <span class="i">namespace</span> <span class="v">std</span>;

<span class="c">// Typy danych</span>

<span class="i">struct</span> <span class="v">slistEl</span>
{
  <span class="v">slistEl</span> * <span class="v">next</span>;
  <span class="i">int</span> <span class="v">v</span>,<span class="v">w</span>;                        <span class="c">// numer wêz³a docelowego i waga krawêdzi</span>
};

<span class="i">const</span> <span class="i">int</span> <span class="v">MAXINT</span> = <span class="n">2147483647</span>;

<span class="c">// **********************</span>
<span class="c">// *** PROGRAM G£ÓWNY ***</span>
<span class="c">// **********************</span>

<span class="i">int</span> <span class="v">main</span>()
{
  <span class="i">int</span> <span class="v">i</span>,<span class="v">j</span>,<span class="v">m</span>,<span class="v">n</span>,<span class="v">v</span>,<span class="v">u</span>,<span class="v">w</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">sptr</span>,*<span class="v">d</span>,*<span class="v">p</span>,*<span class="v">S</span>;
  <span class="i">bool</span> *<span class="v">QS</span>;                       <span class="c">// Zbiory Q i S</span>
  <span class="v">slistEl</span> **<span class="v">graf</span>;                 <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">slistEl</span> *<span class="v">pw</span>,*<span class="v">rw</span>;

  <span class="v">cin</span> &gt;&gt; <span class="v">v</span> &gt;&gt; <span class="v">n</span> &gt;&gt; <span class="v">m</span>;             <span class="c">// Wêze³ startowy, liczba wierzcho³ków i krawêdzi</span>

  <span class="c">// Tworzymy tablice dynamiczne</span>

  <span class="v">d</span> = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];                <span class="c">// Tablica kosztów doj¶cia</span>
  <span class="v">p</span> = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];                <span class="c">// Tablica poprzedników</span>
  <span class="v">QS</span> = <span class="i">new</span> <span class="i">bool</span> [<span class="v">n</span>];              <span class="c">// Zbiory Q i S</span>
  <span class="v">graf</span> = <span class="i">new</span> <span class="v">slistEl</span> * [<span class="v">n</span>];       <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">S</span> = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];                <span class="c">// Stos</span>
  <span class="v">sptr</span> = <span class="n">0</span>;                       <span class="c">// Wska¼nik stosu</span>

  <span class="c">// Inicjujemy tablice dynamiczne</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">d</span>[<span class="v">i</span>] = <span class="v">MAXINT</span>;
    <span class="v">p</span>[<span class="v">i</span>] = -<span class="n">1</span>;
    <span class="v">QS</span>[<span class="v">i</span>] = <span class="i">false</span>;
    <span class="v">graf</span>[<span class="v">i</span>] = <span class="v">NULL</span>;
  }

  <span class="c">// Odczytujemy dane wej¶ciowe</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">m</span>; <span class="v">i</span>++)
  {
    <span class="v">cin</span> &gt;&gt; <span class="v">x</span> &gt;&gt; <span class="v">y</span> &gt;&gt; <span class="v">w</span>;           <span class="c">// Odczytujemy krawêd¼ z wag±</span>
    <span class="v">pw</span> = <span class="i">new</span> <span class="v">slistEl</span>;             <span class="c">// Tworzymy element listy s±siedztwa</span>
    <span class="v">pw</span>-&gt;<span class="v">v</span> = <span class="v">y</span>;                    <span class="c">// Wierzcho³ek docelowy krawêdzi</span>
    <span class="v">pw</span>-&gt;<span class="v">w</span> = <span class="v">w</span>;                    <span class="c">// Waga krawêdzi</span>
    <span class="v">pw</span>-&gt;<span class="v">next</span> = <span class="v">graf</span>[<span class="v">x</span>];
    <span class="v">graf</span>[<span class="v">x</span>] = <span class="v">pw</span>;                 <span class="c">// Element do³±czamy do listy</span>
  }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="v">d</span>[<span class="v">v</span>] = <span class="n">0</span>;                       <span class="c">// Koszt doj¶cia v jest zerowy</span>

  <span class="c">// Wyznaczamy ¶cie¿ki</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="c">// Szukamy wierzcho³ka w Q o najmniejszym koszcie d</span>

    <span class="i">for</span>(<span class="v">j</span> = <span class="n">0</span>; <span class="v">QS</span>[<span class="v">j</span>]; <span class="v">j</span>++);
    <span class="i">for</span>(<span class="v">u</span> = <span class="v">j</span>++; <span class="v">j</span> &lt; <span class="v">n</span>; <span class="v">j</span>++)
      <span class="i">if</span>(!<span class="v">QS</span>[<span class="v">j</span>] &amp;&amp; (<span class="v">d</span>[<span class="v">j</span>] &lt; <span class="v">d</span>[<span class="v">u</span>])) <span class="v">u</span> = <span class="v">j</span>;

    <span class="c">// Znaleziony wierzcho³ek przenosimy do S</span>

    <span class="v">QS</span>[<span class="v">u</span>] = <span class="i">true</span>;

    <span class="c">// Modyfikujemy odpowiednio wszystkich s±siadów u, którzy s± w Q</span>

    <span class="i">for</span>(<span class="v">pw</span> = <span class="v">graf</span>[<span class="v">u</span>]; <span class="v">pw</span>; <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="v">next</span>)
      <span class="i">if</span>(!<span class="v">QS</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] &amp;&amp; (<span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] &gt; <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>))
      {
        <span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>;
        <span class="v">p</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">u</span>;
      }
  }

  <span class="c">// Gotowe, wy¶wietlamy wyniki</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">cout</span> &lt;&lt; <span class="v">i</span> &lt;&lt; <span class="t">": "</span>;

    <span class="c">// ¦cie¿kê przechodzimy od koñca ku pocz±tkowi,</span>
    <span class="c">// Zapisuj±c na stosie kolejne wierzcho³ki</span>

    <span class="i">for</span>(<span class="v">j</span> = <span class="v">i</span>; <span class="v">j</span> &gt; -<span class="n">1</span>; <span class="v">j</span> = <span class="v">p</span>[<span class="v">j</span>]) <span class="v">S</span>[<span class="v">sptr</span>++] = <span class="v">j</span>;

    <span class="c">// Wy¶wietlamy ¶cie¿kê, pobieraj±c wierzcho³ki ze stosu</span>

    <span class="i">while</span>(<span class="v">sptr</span>) <span class="v">cout</span> &lt;&lt; <span class="v">S</span>[--<span class="v">sptr</span>] &lt;&lt; <span class="t">" "</span>;

    <span class="c">// Na koñcu ¶cie¿ki wypisujemy jej koszt</span>

    <span class="v">cout</span> &lt;&lt; <span class="t">"$"</span> &lt;&lt; <span class="v">d</span>[<span class="v">i</span>] &lt;&lt; <span class="v">endl</span>;
  }

  <span class="c">// Usuwamy tablice dynamiczne</span>

  <span class="i">delete</span> [] <span class="v">d</span>;
  <span class="i">delete</span> [] <span class="v">p</span>;
  <span class="i">delete</span> [] <span class="v">QS</span>;
  <span class="i">delete</span> [] <span class="v">S</span>;

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">pw</span> = <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span>(<span class="v">pw</span>)
    {
      <span class="v">rw</span> = <span class="v">pw</span>;
      <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="v">next</span>;
      <span class="i">delete</span> <span class="v">rw</span>;
    }
  }

  <span class="i">delete</span> [] <span class="v">graf</span>;

  <span class="i">return</span> <span class="n">0</span>;
} </pre></pre>
				</td>
			</tr>
			<tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Free Basic</b></td>
			</tr>
			<tr>
				<td style="text-align: left">
				<pre id="bas"><pre><span class="c">' Algorytm Dijkstry z wyszukiwaniem liniowym</span>
<span class="c">' Data: 15.03.2014</span>
<span class="c">' (C)2014 mgr Jerzy Wa³aszek</span>
<span class="c">'-------------------------------------------</span>

<span class="c">' Typy danych</span>

<span class="i">Type</span> <span class="v">slistEl</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Next</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">v</span>,<span class="v">w</span>              <span class="c">' numer wêz³a docelowego i waga krawêdzi</span>
<span class="i">End</span> <span class="i">Type</span>

<span class="i">Const</span> <span class="v">MAXINT</span> = <span class="n">2147483647</span>

<span class="c">' **********************</span>
<span class="c">' *** PROGRAM G£ÓWNY ***</span>
<span class="c">' **********************</span>

<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">i</span>,<span class="v">j</span>,<span class="v">m</span>,<span class="v">n</span>,<span class="v">v</span>,<span class="v">u</span>,<span class="v">w</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">sptr</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="i">Ptr</span> <span class="v">d</span>,<span class="v">p</span>,<span class="v">S</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="i">Byte</span> <span class="i">Ptr</span> <span class="v">QS</span>               <span class="c">' Zbiory Q i S</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span> <span class="v">graf</span>      <span class="c">' Tablica list s±siedztwa</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">pw</span>,<span class="v">rw</span>

<span class="i">Open</span> <span class="i">Cons</span> <span class="i">For</span> <span class="i">Input</span> <span class="i">As</span> #<span class="n">1</span>

<span class="i">Input</span> #<span class="n">1</span>,<span class="v">v</span>,<span class="v">n</span>,<span class="v">m</span>                   <span class="c">' Wêze³ startowy, liczba wierzcho³ków i krawêdzi</span>

<span class="c">' Tworzymy tablice dynamiczne</span>

<span class="v">d</span> = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]              <span class="c">' Tablica kosztów doj¶cia</span>
<span class="v">p</span> = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]              <span class="c">' Tablica poprzedników</span>
<span class="v">QS</span> = <span class="i">New</span> <span class="i">Byte</span> [<span class="v">n</span>]                <span class="c">' Zbiory Q i S</span>
<span class="v">graf</span> = <span class="i">New</span> <span class="v">slistEl</span> <span class="i">Ptr</span> [<span class="v">n</span>]       <span class="c">' Tablica list s±siedztwa</span>
<span class="v">S</span> = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]              <span class="c">' Stos</span>
<span class="v">sptr</span> = <span class="n">0</span>                         <span class="c">' Wska¼nik stosu</span>

<span class="c">' Inicjujemy tablice dynamiczne</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">d</span>[<span class="v">i</span>] = <span class="v">MAXINT</span>
  <span class="v">p</span>[<span class="v">i</span>] = -<span class="n">1</span>
  <span class="v">QS</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">graf</span>[<span class="v">i</span>] = <span class="n">0</span>
<span class="i">Next</span>

<span class="c">' Odczytujemy dane wej¶ciowe</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">m</span> - <span class="n">1</span>
  <span class="i">Input</span> #<span class="n">1</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">w</span>                  <span class="c">' Odczytujemy krawêd¼ z wag±</span>
  <span class="v">pw</span> = <span class="i">New</span> <span class="v">slistEl</span>                <span class="c">' Tworzymy element listy s±siedztwa</span>
  <span class="v">pw</span>-&gt;<span class="v">v</span> = <span class="v">y</span>                       <span class="c">' Wierzcho³ek docelowy krawêdzi</span>
  <span class="v">pw</span>-&gt;<span class="v">w</span> = <span class="v">w</span>                       <span class="c">' Waga krawêdzi</span>
  <span class="v">pw</span>-&gt;<span class="i">Next</span> = <span class="v">graf</span>[<span class="v">x</span>]
  <span class="v">graf</span>[<span class="v">x</span>] = <span class="v">pw</span>                    <span class="c">' Element do³±czamy do listy</span>
<span class="i">Next</span>

<span class="i">Close</span> #<span class="n">1</span>

<span class="i">Print</span>

<span class="v">d</span>[<span class="v">v</span>] = <span class="n">0</span>                          <span class="c">' Koszt doj¶cia v jest zerowy</span>

<span class="c">' Wyznaczamy ¶cie¿ki</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>

  <span class="c">' Szukamy wierzcho³ka w Q o najmniejszym koszcie d</span>

  <span class="v">j</span> = <span class="n">0</span>
  <span class="i">While</span> <span class="v">QS</span>[<span class="v">j</span>] = <span class="n">1</span>
  	 <span class="v">j</span> += <span class="n">1</span>
  <span class="i">Wend</span>
  <span class="v">u</span> = <span class="v">j</span>
  <span class="v">j</span> += <span class="n">1</span>
  <span class="i">While</span> <span class="v">j</span> &lt; <span class="v">n</span>
    <span class="i">If</span> (<span class="v">QS</span>[<span class="v">j</span>] = <span class="n">0</span>) <span class="i">Andalso</span> (<span class="v">d</span>[<span class="v">j</span>] &lt; <span class="v">d</span>[<span class="v">u</span>]) <span class="i">Then</span> <span class="v">u</span> = <span class="v">j</span>
    <span class="v">j</span> += <span class="n">1</span>
  <span class="i">Wend</span>
  
  <span class="c">' Znaleziony wierzcho³ek przenosimy do S</span>

  <span class="v">QS</span>[<span class="v">u</span>] = <span class="n">1</span>

  <span class="c">' Modyfikujemy odpowiednio wszystkich s±siadów u, którzy s± w Q</span>

  <span class="v">pw</span> = <span class="v">graf</span>[<span class="v">u</span>]
  <span class="i">While</span> <span class="v">pw</span>
    <span class="i">If</span> (<span class="v">QS</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="n">0</span>) <span class="i">Andalso</span> (<span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] &gt; <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>) <span class="i">Then</span>
      <span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>
      <span class="v">p</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">u</span>
    <span class="i">End</span> <span class="i">If</span>
    <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="i">Next</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="c">' Gotowe, wy¶wietlamy wyniki</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="i">Print</span> <span class="v">i</span>;<span class="t">":"</span>;

  <span class="c">' ¦cie¿kê przechodzimy od koñca ku pocz±tkowi,</span>
  <span class="c">' Zapisuj±c na stosie kolejne wierzcho³ki</span>

  <span class="v">j</span> = <span class="v">i</span>
  <span class="i">While</span> <span class="v">j</span> &gt; -<span class="n">1</span>
  	 <span class="v">S</span>[<span class="v">sptr</span>] = <span class="v">j</span>
  	 <span class="v">sptr</span> += <span class="n">1</span>
  	 <span class="v">j</span> = <span class="v">p</span>[<span class="v">j</span>]
  <span class="i">Wend</span>

  <span class="c">' Wy¶wietlamy ¶cie¿kê, pobieraj±c wierzcho³ki ze stosu</span>

  <span class="i">While</span> <span class="v">sptr</span> &gt; <span class="n">0</span>
  	 <span class="v">sptr</span> -= <span class="n">1</span>
  	 <span class="i">Print</span> <span class="v">S</span>[<span class="v">sptr</span>];
  <span class="i">Wend</span>

  <span class="c">' Na koñcu ¶cie¿ki wypisujemy jej koszt</span>

  <span class="i">Print</span> <span class="i">Using</span> <span class="t">" $&amp;"</span>;<span class="v">d</span>[<span class="v">i</span>]
<span class="i">Next</span>

<span class="c">' Usuwamy tablice dynamiczne</span>

<span class="i">Delete</span> [] <span class="v">d</span>
<span class="i">Delete</span> [] <span class="v">p</span>
<span class="i">Delete</span> [] <span class="v">QS</span>
<span class="i">Delete</span> [] <span class="v">S</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">pw</span> = <span class="v">graf</span>[<span class="v">i</span>]
  <span class="i">While</span> <span class="v">pw</span>
    <span class="v">rw</span> = <span class="v">pw</span>
    <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">rw</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Delete</span> [] <span class="v">graf</span>

<span class="i">End</span> </pre></pre>
				</td>
			</tr>
			<tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Wynik</b></td>
			</tr>
			<tr>
				<td style="text-align: left" class="program">0 6 9<br>
				0 1 3<br>
				0 4 3<br>
				1 2 1<br>
				2 3 3<br>
				2 5 1<br>
				3 1 3<br>
				4 5 2<br>
				5 0 6<br>
				5 3 1<br>
				<br>
				0: 0 $0<br>
				1: 0 1 $3<br>
				2: 0 1 2 $4<br>
				3: 0 4 5 3 $6<br>
				4: 0 4 $3<br>
				5: 0 4 5 $5</td>
			</tr>
		</tbody></table></div>
	<p>&nbsp;</p></div>
<h4><a name="A2"></a>Algorytm Dijkstry z kolejk± priorytetow± w postaci kopca - 
wersja pogl±dowa</h4>
<div class="sb1">
	<p>Aby efektywnie wykorzystaæ kopiec w algorytmie Dijkstry znajdowania 
	najkrótszych ¶cie¿ek w grafie, w elementach kopca zapamiêtujemy numery 
	wierzcho³ków grafu. Poprzez te numery mo¿emy siê prosto odwo³ywaæ do tablicy 
	<i>d</i> przechowuj±cej aktualne koszty doj¶cia do danego wierzcho³ka w grafie. 
	Równie¿ wierzcho³ki grafu powinny pamiêtaæ swoj± pozycjê w kopcu. Dziêki 
	temu szybko odnajdziemy wierzcho³ek, którego koszt <i>d</i><span class="f">
	</span>zosta³ zmodyfikowany. 
	Pozycjê wierzcho³ka grafu w kopcu mo¿na przechowywaæ w dodatkowej tablicy
	<i>hp</i> zawieraj±cej <span class="f">n</span> elementów typu ca³kowitego.</p>
	<p>Przed rozpoczêciem pracy nale¿y kopiec utworzyæ. Poniewa¿ wszystkie 
	wierzcho³ki grafu otrzymuj± pocz±tkowo warto¶æ <i>d</i> równ± nieskoñczono¶ci, 
	mo¿na je kolejno wpisaæ do struktury kopca. Nastêpnie wybrany element <i>v</i> 
	w kopcu wymieniamy z elementem pierwszym. Dziêki tej operacji znajdzie siê 
	on w korzeniu kopca i zostanie wybrany jako element grafu o najmniejszej 
	warto¶ci kosztu <i>d</i>.</p></div>
<h4>U¿ywane struktury danych:</h4>
<blockquote>
	<table id="table3" style="border-collapse: collapse" border="0" cellpadding="2">
		<tbody><tr>
			<td valign="top" nowrap="nowrap"><i>n</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">liczba wierzcho³ków w grafie</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>graf</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
			<td valign="top">zadany w dowolnie wybrany sposób, algorytm tego nie 
				precyzuje.</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>v</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">wybrany wierzcho³ek grafu, <i>v</i>
					<img alt="symbol" src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_symbol_05.gif" width="8" border="0" height="8">
					<i>V</i>, który jest pocz±tkiem wyznaczania najkrótszych ¶cie¿ek 
				do wszystkich pozosta³ych wierzcho³ków </td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>d</i>[<i>i</i>]</td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">koszt doj¶cia od wierzcho³ka v do wierzcho³ka <i>i</i>-tego 
				wzd³u¿ najkrótszej ¶cie¿ki. Koszt doj¶cia jest sum± wag 
				krawêdzi, przez które przechodzimy posuwaj±c siê wzd³u¿ 
				wyznaczonej najkrótszej ¶cie¿ki.</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap">p[i]</td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">dla <i>i</i>-tego wierzcho³ka 
				grafu <i>p</i>[<i>i</i>] 
				zawiera numer wierzcho³ka poprzedzaj±cego na najkrótszej ¶cie¿ce</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>w</i>[<i>i&#8211;j</i>]</td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">waga ¶cie¿ki pomiêdzy wierzcho³kami
				<i>i</i> a <i>j</i> <span class="rem">(graf nieskierowany)</span> lub od wierzcho³ka
				<i>i</i>-tego do <i>j</i>-tego <span class="rem">(graf skierowany)</span></td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>S</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">zbiór wierzcho³ków grafu o policzonych ju¿ 
				najkrótszych ¶cie¿kach od wybranego wierzcho³ka <i>v</i></td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>Q</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">zbiór wierzcho³ków grafu, dla których 
				najkrótsze ¶cie¿ki nie zosta³y jeszcze policzone</td>
		</tr>
	</tbody></table>
</blockquote>
<h4>Dane wej¶ciowe:</h4>
<blockquote>
	<p><i>n, graf, v</i></p>
</blockquote>
<h4>Dane wyj¶ciowe:</h4>
<blockquote>
	<p>Dla ka¿dego wierzcho³ka <i>i</i> algorytm wyznacza koszt doj¶cia <i>d</i>[<i>i</i>] 
		oraz poprzednika <i>p</i>[<i>i</i>]
		na najkrótszej ¶cie¿ce.</p>
	<p>&nbsp;</p>
	<table id="table283" style="border-collapse: collapse" border="0" cellpadding="4">
		<tbody><tr>
			<td valign="top" align="right">K01:</td>
			<td><i>S</i> &#8592; &#216;;&nbsp;&nbsp;
				<i>Q</i> &#8592; wszystkie wierzcho³ki grafu</td>
		</tr>
		<tr>
			<td valign="top" align="right">K02:</td>
			<td><b>Dla</b> <i>i</i> = 0,1,...,n - 1 <b>wykonaj</b>: <i>p</i>[<i>i</i>] &#8592; 
			-1;&nbsp; <i>d</i>[i] &#8592;<font face="Symbol"> &#165;</font></td>
		</tr>
		<tr>
			<td valign="top" align="right"><font color="#FF0000">K03:</font></td>
			<td><font color="#FF0000">Ustaw kopiec</font></td>
		</tr>
		<tr>
			<td valign="top" align="right">K04:</td>
			<td><i>d</i>[<i>v</i>] &#8592; 0</td>
		</tr>
		<tr>
			<td valign="top" align="right"><font color="#FF0000">K05:</font></td>
			<td><font color="#FF0000">Odtwórz w³asno¶æ kopca po zmianie 
				<i>d</i>[<i>v</i>]</font></td>
		</tr>
		<tr>
			<td valign="top" align="right">K06:</td>
			<td><b>Dopóki</b> <i>Q</i> &#8800; &#216;<b> 
				wykonuj kroki</b> K05...K07</td>
		</tr>
		<tr>
			<td valign="top" align="right"><font color="#FF0000">K07:</font></td>
			<td>&nbsp;&nbsp;&nbsp;<font color="#FF0000"> <i>u</i> &#8592;
				korzeñ kopca</font></td>
		</tr>
		<tr>
			<td valign="top" align="right"><font color="#FF0000">K08:</font></td>
			<td>&nbsp;&nbsp;&nbsp; <font color="#FF0000">Usuñ korzeñ z kopca i odtwórz w³asno¶æ 
				kopca</font></td>
		</tr>
		<tr>
			<td valign="top" align="right">K09:</td>
			<td>&nbsp;&nbsp;&nbsp; Wierzcho³ek <i>u</i> przenie¶ z <i>Q</i> do<i> S</i></td>
		</tr>
		<tr>
			<td valign="top" align="right"><font color="#FF0000">K10</font>:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Dla</b> ka¿dego <i>v</i>
			<font face="Symbol">Î</font> <i>Q</i>, takiego ¿e krawêd¼ <i>u&#8211;v</i>
					<img alt="symbol" src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/000_symbol_05.gif" width="8" border="0" height="8">
					graf, <b>je¶li</b> <i>d</i>[<i>v</i>] 
				&gt; <i>d</i>[<i>u</i>] 
				+ <i>w</i>[<i>u&#8211;v</i>], 
				<b>to</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>d</i>[<i>v</i>] &#8592;
			<i>d</i>[<i>u</i>] 
				+ <i>w</i>[<i>u&#8211;v</i>];&nbsp;&nbsp; <i>p</i>[<i>v</i>] &#8592; 
			<i>u</i>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			<font color="#FF0000">odtwórz w³asno¶æ kopca po zmianie
				<i>d</i>[<i>v</i>].</font></td>
		</tr>
		<tr>
			<td valign="top" align="right">K11:</td>
			<td><b>Zakoñcz</b></td>
		</tr>
	</tbody></table>
</blockquote>
<p>Przy implementacji algorytmu Dijkstry z kolejk± priorytetow± zastosujemy 
	podobne ustalenia jak dla implementacji z wyszukiwaniem liniowym:</p>
<ol>
	<li>Zbiory <i>S</i> i <i>Q</i> bêd± 
		odwzorowane w tablicy logicznej <i>QS</i> o <i>n</i> elementach. Element
		<i>i</i>-ty odnosi siê do wierzcho³ka grafu o numerze
		<i>i</i>-tym:<br><i>QS</i>[<i>i</i>] 
		= false &#8211; wierzcho³ek <i>i</i>-ty nale¿y do 
		zbioru <i>Q</i><br><i>QS</i>[<i>i</i>] 
		= true&nbsp; &#8211; wierzcho³ek <i>i</i>-ty nale¿y do zbioru
		<i>S</i></li>
	<li>Graf odwzorowujemy w <i>n</i>-elementow± tablicê 
		list s±siedztwa.</li>
	<li>Koszty doj¶cia <i>d</i> 
		zrealizujemy w postaci <i>n</i>-elementowej tablicy 
		liczb ca³kowitych. Element <i>d</i>[<i>i</i>] 
		okre¶la koszt doj¶cia do wierzcho³ka <i>i</i>-tego.</li>
	<li>Poprzedniki <i>p</i> 
		równie¿ bêd± zrealizowane w formie tablicy <i>n</i>-elementowej 
		liczb ca³kowitych. Element <i>p</i>[<i>i</i>] 
		zawiera numer wierzcho³ka poprzedzaj±cego wierzcho³ek <i>i</i>-ty 
		na najkrótszej ¶cie¿ce z <i>v</i> 
		do <i>i</i>. Wierzcho³ki numerujemy poczynaj±c od 0. 
		Zatem zawarto¶æ p[<i>i</i>] = -1 
		informuje nas od razu, i¿ wierzcho³ek <i>i</i>-ty nie 
		posiada poprzednika, zatem nie istnieje ¶cie¿ka z <i>v</i> 
		do <i>i</i>.</li>
	<li>Pêtla z kroku 6 bêdzie zrealizowana w formie zwyk³ej pêtli 
		iteracyjnej wykonywanej <i>n</i> razy. Powodem jest to, 
		i¿ przy ka¿dym obiegu tej pêtli jeden wierzcho³ek grafu przechodzi 
		zawsze ze zbioru <i>Q</i> do <i>S</i>, 
		zatem zbiór <i>Q</i> stanie siê pusty po przeniesieniu
		<i>n</i> wierzcho³ków, czyli po wykonaniu
		<i>n</i> obiegów.</li>
	<li>Algorytm wykorzystuje kopiec do wyszukiwania wierzcho³ków o 
		najmniejszym koszcie doj¶cia. Kopiec zrealizujemy w <i>n</i>-elementowej 
		tablicy <i>h</i>. 
		W kopcu bêdziemy przechowywali numery wierzcho³ków grafu. Poniewa¿ 
		potrzebna nam bêdzie równie¿ informacja o po³o¿eniu danego wierzcho³ka w 
		strukturze kopca <span class="rem">(np. przy modyfikacji kosztu w kroku 
		10)</span>, zatem zastosujemy dodatkow± <i>n</i>-elementow± 
		tablicê <i>hp</i>, 
		w której element <i>hp</i>[<i>i</i>] 
		bêdzie przechowywa³ po³o¿enie <i>i</i>-tego wierzcho³ka 
		w kopcu. Oczywi¶cie przy modyfikacji kopca równie¿ niezbêdna bêdzie 
		odpowiednia modyfikacja tablicy <i>hp</i>, 
		aby zachowaæ spójno¶æ danych. Dodatkowo musimy pamiêtaæ aktualn± d³ugo¶æ 
		kopca w zmiennej <i>h<sub>len</sub></i>.</li>
</ol>
<h4>Operacja z kroku 3: ustaw kopiec</h4>
<div class="sb1">
	<p>Zadaniem tej operacji jest odpowiednia inicjalizacja struktury kopca. 
	Poniewa¿ na pocz±tku algorytmu Dijkstry dla wszystkich wierzcho³ków koszt 
	doj¶cia <nobr><i>d</i>[<i>i</i>] </nobr>przyjmuje warto¶æ nieskoñczon± 
	<span class="rem">(w praktyce najwiêksz± mo¿liw±)</span>, to nie ma 
	istotnego znaczenia, w którym miejscu kopca dany wierzcho³ek siê znajdzie, 
	gdy¿ w³asno¶æ kopca bêdzie zachowana. 
	Zatem wierzcho³ki rozmieszczamy kolejno zgodnie z ich numeracj±.</p>
	<table id="table284" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
		<tbody><tr>
			<td valign="top" align="right">K01:</td>
			<td><i>h<sub>len</sub></i> &#8592; <i>n</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K02:</td>
			<td><b>Dla</b> <i>i</i> = 
				0,1,...,<i>n</i> - 1 <b>wykonuj</b>: <i>h</i>[<i>i</i>] &#8592; 
			<i>i</i>;&nbsp;&nbsp; <i>hp</i>[<i>i</i>] &#8592; <i>i</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K03:</td>
			<td><b>Koniec</b></td>
		</tr>
	</tbody></table>
	<p>&nbsp;</p></div>
<h4>Operacja z kroku 5:<span class="f"> </span>odtworzenie w³asno¶ci kopca 
	po zmianie <i>d</i>[<i>v</i>]</h4>
<div class="sb1">
	<p>Koszt doj¶cia do elementu startowego <i>v</i> ustalamy zawsze na 0. Operacja ta mo¿e zaburzyæ 
	strukturê kopca, je¶li <i>v</i> 
	nie jest umieszczony w korzeniu. Poniewa¿ wszystkie pozosta³e wierzcho³ki na 
	tym etapie posiadaj± koszty <i>d</i>[<i>i</i>] = nieskoñczono¶æ, to wystarczy zamieniæ
	<i>h</i>[<i>v</i>]
	z <i>h</i>[0] 
	oraz odpowiednio ustawiæ tablicê <i>hp</i>.</p>
	<table id="table5" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
		<tbody><tr>
			<td valign="top" align="right">K01:</td>
			<td><i>h</i>[0] &#8596; h[<i>v</i>]</td>
		</tr>
		<tr>
			<td valign="top" align="right">K02:</td>
			<td><i>hp</i>[v]
				&#8592; 0;&nbsp;&nbsp;&nbsp; <i>hp</i>[0] &#8592; <i>v</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K03:</td>
			<td><b>Koniec</b></td>
		</tr>
	</tbody></table>
	<p>&nbsp;</p></div>
<h4>Operacja z kroku 7:&nbsp; u &#8592;
				korzeñ kopca</h4>
<div class="sb1">
	<p>Korzeñ kopca zawsze jest w <i>h</i>[0], 
	zatem:</p>
	<table id="table6" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
		<tbody><tr>
			<td valign="top" align="right">K01:</td>
			<td><i>u</i> &#8592; 
				<i>h</i>[0]</td>
		</tr>
		<tr>
			<td valign="top" align="right">K02:</td>
			<td><b>Koniec</b></td>
		</tr>
	</tbody></table>
	<p>&nbsp;</p></div>
<h4>Operacja z kroku 8: usuñ korzeñ z kopca i odtwórz w³asno¶æ kopca</h4>
<div class="sb1">
	<p>Po pobraniu z kopca najmniejszego elementu musimy usun±æ korzeñ. 
	Posuwamy siê w dó³ 
	hierarchii kopca:</p>
	<h5>U¿ywane struktury danych:</h5>
	<table id="table8" style="border-collapse: collapse" class="sb1" border="0" cellpadding="2">
		<tbody><tr>
			<td valign="top" nowrap="nowrap"><i>h<sub>len</sub></i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;&nbsp;</td>
			<td valign="top">ilo¶æ elementów w kopcu</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>parent</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">indeks wierzcho³ka nadrzêdnego</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>left</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">indeks lewego potomka</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>right</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">indeks prawego potomka</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>d<sub>min</sub></i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">mniejsza warto¶æ kosztu doj¶cia do lewego lub 
				prawego potomka</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>p<sub>min</sub></i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">indeks potomka zawieraj±cego mniejsz± warto¶æ 
				kosztu doj¶cia</td>
		</tr>
	</tbody></table>
	<h5>Lista kroków</h5>
	<table id="table7" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
		<tbody><tr>
			<td valign="top" align="right">K01:</td>
			<td><i>h</i>[0] &#8592; <i>h</i>[<i>h<sub>len</sub></i> - 1];&nbsp;
				<i>h<sub>len</sub></i> &#8592; <i>h<sub>len</sub></i> 
				- 1</td>
		</tr>
		<tr>
			<td valign="top" align="right">K02:</td>
			<td><i>hp</i>[ 
				<i>h</i>[0] ] &#8592; 0</td>
		</tr>
		<tr>
			<td valign="top" align="right">K03:</td>
			<td><i>parent</i> &#8592; 0</td>
		</tr>
		<tr>
			<td valign="top" align="right">K04:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>left</i> &#8592; 2 x
				<i>parent</i> + 1;&nbsp;
				<i>right</i> &#8592; <i>left</i> 
				+ 1</td>
		</tr>
		<tr>
			<td valign="top" align="right">K05:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>left</i>
			<font face="Times New Roman">&#8805;</font> <i>h<sub>len</sub></i>, 
				<b>to zakoñcz</b></td>
		</tr>
		<tr>
			<td valign="top" align="right">K06:</td>
			<td>&nbsp;&nbsp; &nbsp;<i>d<sub>min</sub></i> &#8592; <i>d</i>[ <i>h</i>[<i>left</i>] 
				];&nbsp; <i>p<sub>min</sub></i> &#8592; <i>left</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K07:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>right</i>
			<font face="Times New Roman">&#8805;</font> <i>h<sub>len</sub></i>, <b>to id¼ do kroku</b> K09</td>
		</tr>
		<tr>
			<td valign="top" align="right">K08:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>d<sub>min</sub></i> 
				&gt; <i>d</i>[ <i>h</i>[<i>right</i>] 
				], <b>to</b>&nbsp; <i>d<sub>min</sub></i> &#8592; <i>d</i>[ <i>h</i>[<i>right</i>] 
				];&nbsp;&nbsp; <i>p<sub>min</sub></i>
				&#8592; <i>right</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K09:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>d</i>[ <i>h</i>[<i>parent</i>] 
				] &#8804; <i>d<sub>min</sub></i>, <b>to zakoñcz</b></td>
		</tr>
		<tr>
			<td valign="top" align="right">K10:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>h</i>[<i>parent</i>] 
				&#8596; <i>h</i>[<i>p<sub>min</sub></i>]</td>
		</tr>
		<tr>
			<td valign="top" align="right">K11:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>hp</i>[
				<i>h</i>[<i>parent</i>] 
				] &#8592; <i>parent</i>;&nbsp;&nbsp;
				<i>hp</i>[ <i>h</i>[<i>p<sub>min</sub></i>] 
				] &#8592; <i>p<sub>min</sub></i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K12:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>parent</i> &#8592; <i>p<sub>min</sub></i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K13:</td>
			<td><b>Id¼ do kroku</b> K04</td>
		</tr>
	</tbody></table>
	<p>&nbsp;</p></div>
<h3>Operacja z kroku 10: odtwórz w³asno¶æ kopca po zmianie d(v)</h3>
<div class="sb1">
	<p>Algorytm zmodyfikowa³ koszt doj¶cia do wierzcho³ka <i>v</i> 
	po³±czonego krawêdzi± ze znalezionym wcze¶niej wierzcho³kiem <span class="f">u</span> grafu. W takim przypadku w³asno¶æ kopca zostaje zaburzona w okolicy 
	wierzcho³ka <i>v</i> w kopcu. Musimy j± przywróciæ. Posuwamy 
	siê w górê hierarchii kopca:</p>
	<h4>U¿ywane struktury danych:</h4>
	<table id="table9" style="border-collapse: collapse" class="sb1" border="0" cellpadding="0">
		<tbody><tr>
			<td valign="top" nowrap="nowrap"><i>parent</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;&nbsp;</td>
			<td valign="top">indeks elementu nadrzêdnego w hierarchii kopca</td>
		</tr>
		<tr>
			<td valign="top" nowrap="nowrap"><i>child</i></td>
			<td valign="top" nowrap="nowrap">&nbsp;&#8211;</td>
			<td valign="top">indeks elementu potomnego</td>
		</tr>
	</tbody></table>
	<h4>Lista kroków</h4>
	<table id="table10" style="border-collapse: collapse" class="sb1" border="0" cellpadding="4">
		<tbody><tr>
			<td valign="top" align="right">K01:</td>
			<td><i>child</i>&nbsp; &#8592; <i>hp</i>[<i>v</i>]</td>
		</tr>
		<tr>
			<td valign="top" align="right">K02:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>child</i> 
				= 0, <b>to zakoñcz</b></td>
		</tr>
		<tr>
			<td valign="top" align="right">K03:</td>
			<td>&nbsp; &nbsp; <i>parent</i> &#8592; [(<i>child</i> - 1) / 2]</td>
		</tr>
		<tr>
			<td valign="top" align="right">K04:</td>
			<td>&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>d</i>[ <i>h</i>[<i>parent</i>]] 
				&#8804; <i>d</i>[ <i>h</i>[<i>child</i>]], 
				<b>to zakoñcz</b></td>
		</tr>
		<tr>
			<td valign="top" align="right">K05:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>h</i>[<i>parent</i>] 
				&#8596; <i>h</i>[<i>child</i>]</td>
		</tr>
		<tr>
			<td valign="top" align="right">K06:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>hp</i>[
				<i>h</i>[<i>parent</i>] 
				] &#8592; <i>parent</i>;&nbsp;&nbsp;
				<i>hp</i>[ <i>h</i>[<i>child</i>] 
				] &#8592; <i>child</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K07:</td>
			<td>&nbsp;&nbsp;&nbsp; <i>child</i> &#8592; <i>parent</i></td>
		</tr>
		<tr>
			<td valign="top" align="right">K08:</td>
			<td><b>Id¼ do kroku</b> K02</td>
		</tr>
	</tbody></table>
	<div class="sb1">&nbsp;</div></div>
<blockquote>
	<p>Podstawowym zyskiem zastosowania kolejki priorytetowej w algorytmie 
	Dijkstry jest zmniejszenie klasy z³o¿ono¶ci obliczeniowej z 
	<nobr><i>O</i><span style="font-style: normal">(</span><i>n</i><span style="font-style: normal"><sup>2</sup>)</span>
	</nobr>na <nobr><i>O</i><span style="font-style: normal">(</span><i>n</i>
	<span style="font-style: normal">log</span> <i>n</i><span style="font-style: normal">)</span>.</nobr> 
	Jednak¿e z drugiej strony sam algorytm siê komplikuje i ro¶nie 
	zapotrzebowanie na pamiêæ. Dlatego dla ma³ych grafów wci±¿ efektywnym 
	rozwi±zaniem mo¿e byæ wersja z wyszukiwaniem liniowym.</p>
</blockquote>
<blockquote>
	<p>Czêsto interesuje nas znalezienie najkrótszej ¶cie¿ki pomiêdzy wybranymi 
	wierzcho³kami w grafie - reszta ¶cie¿ek jest nam niepotrzebna. W takim 
	przypadku przedstawiony algorytm Dijkstry koñczymy w kroku, w którym 
	pobieramy wierzcho³ek u o najmniejszym koszcie ze 
	zbioru <i>Q</i> i jest on wierzcho³kiem koñcowym szukanej 
	¶cie¿ki. Pozwala to efektywnie konstruowaæ algorytmy znajduj±ce np. 
	najlepsze trasy przechodz±ce poprzez zadane wierzcho³ki w grafie.</p>
</blockquote>

	<h4>Program</h4>
	<div class="sb1">
		<table style="border-collapse: collapse" border="0" cellpadding="8">
			<tbody><tr>
				<td class="note"><b>Wa¿ne</b>:<br>
				<p class="bl1">Zanim uruchomisz program, przeczytaj 
				<a target="_blank" href="http://edu.i-lo.tarnow.pl/inf/alg/001_search/0001.php#konsola">wstêp</a> do tego artyku³u, w którym wyja¶niamy 
      funkcje tych programów oraz sposób korzystania z nich. </p></td>
			</tr>
		</tbody></table>
		<p>&nbsp;</p></div>
	<div class="sb1">
	Poni¿szy program jest przyk³adow± realizacj± 
	algorytmu Dijkstry z kolejk± priorytetow± opart± na kopcu binarnym. 
	Definicja danych wej¶ciowych jest nastêpuj±ca:<p>&nbsp;</p>
		<div class="bl1">
	W pierwszym wierszu program odczytuje kolejno numer wierzcho³ka startowego v, 
	liczbê wierzcho³ków <i>n</i> oraz liczbê krawêdzi <i>m</i>. W <i>m</i> 
	kolejnych wierszach znajduj± siê definicje krawêdzi. Definicja sk³ada siê z 
	trzech liczb <i>x y w</i>. Pierwsza i druga liczba okre¶la wierzcho³ki grafu, które 
	s± ze sob± po³±czone t± krawêdzi± &#8211; krawêd¼ biegnie od wierzcho³ka <i>x</i> do 
	wierzcho³ka <i>y</i>. Trzecia liczba jest wag± krawêdzi <i>w</i>.<p>Na wyj¶ciu program wypisuje znalezione najkrótsze ¶cie¿ki od wierzcho³ka 
	<i>v</i> do wszystkich pozosta³ych wierzcho³ków. Oprócz ¶cie¿ki wypisywany jest 
	równie¿ koszt przej¶cia tej ¶cie¿ki.</p>
			<p>&nbsp;</p>
		</div>
	<p>Przyk³adowe dane:</p>
	<blockquote>
      <table id="table285" style="border-collapse: collapse" border="0" cellpadding="4">
        <tbody><tr>
          <td>
          		<img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/0138_03.gif" width="218" border="0" height="171"></td>
          <td>0 6 9<br>
			0 1 3<br>
			0 4 3<br>
			1 2 1<br>
			2 3 3<br>
			2 5 1<br>
			3 1 3<br>
			4 5 2<br>
			5 0 6<br>
			5 3 1</td>
        </tr>
      </tbody></table>
    </blockquote>
    &nbsp;<table id="table286" style="border-collapse: collapse" border="1" bordercolor="#808080" cellpadding="4" cellspacing="0">
			<tbody><tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Lazarus</b></td>
			</tr>
			<tr>
				<td style="text-align: left">
				<pre id="pas"><pre><span class="c">// Algorytm Dijkstry z kolejk± priorytetow±</span>
<span class="c">// Data: 16.03.2014</span>
<span class="c">// (C)2014 mgr Jerzy Wa³aszek</span>
<span class="c">//-----------------------------------------</span>

<span class="i">program</span> <span class="v">dijkstra</span>;

<span class="c">// Typy danych</span>

<span class="i">type</span>
  <span class="v">PslistEl</span> = ^<span class="v">slistEl</span>;
  <span class="v">slistEl</span> =  <span class="i">record</span>
    <span class="v">next</span>  : <span class="v">PslistEl</span>;
    <span class="v">v</span>,<span class="v">w</span>   : <span class="v">integer</span>;              <span class="c">// numer wêz³a docelowego i waga krawêdzi</span>
  <span class="i">end</span>;

<span class="c">// **********************</span>
<span class="c">// *** PROGRAM G£ÓWNY ***</span>
<span class="c">// **********************</span>

<span class="i">var</span>
  <span class="v">i</span>,<span class="v">j</span>,<span class="v">m</span>,<span class="v">n</span>,<span class="v">v</span>,<span class="v">u</span>,<span class="v">w</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">sptr</span>,<span class="v">hlen</span>,<span class="v">parent</span>,<span class="v">left</span>,<span class="v">right</span>,<span class="v">dmin</span>,<span class="v">pmin</span>,<span class="v">child</span> : <span class="v">integer</span>;
  <span class="v">d</span>,<span class="v">p</span>,<span class="v">S</span>,<span class="v">h</span>,<span class="v">hp</span> : <span class="i">array</span> <span class="i">of</span> <span class="v">integer</span>;
  <span class="v">QS</span>    : <span class="i">array</span> <span class="i">of</span> <span class="v">boolean</span>;       <span class="c">// Zbiory Q i S</span>
  <span class="v">graf</span>  : <span class="i">array</span> <span class="i">of</span> <span class="v">PslistEl</span>;      <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">pw</span>,<span class="v">rw</span> : <span class="v">PslistEl</span>;

<span class="i">begin</span>
  <span class="v">read</span>(<span class="v">v</span>,<span class="v">n</span>,<span class="v">m</span>);                    <span class="c">// Wêze³ startowy, liczba wierzcho³ków i krawêdzi</span>

  <span class="c">// Tworzymy tablice dynamiczne</span>

  <span class="v">SetLength</span>(<span class="v">d</span>,<span class="v">n</span>);                 <span class="c">// Tablica kosztów doj¶cia</span>
  <span class="v">SetLength</span>(<span class="v">p</span>,<span class="v">n</span>);                 <span class="c">// Tablica poprzedników</span>
  <span class="v">SetLength</span>(<span class="v">QS</span>,<span class="v">n</span>);                <span class="c">// Zbiory Q i S</span>
  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="v">n</span>);              <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">SetLength</span>(<span class="v">S</span>,<span class="v">n</span>);                 <span class="c">// Stos</span>
  <span class="v">SetLength</span>(<span class="v">h</span>,<span class="v">n</span>);                 <span class="c">// Kopiec</span>
  <span class="v">SetLength</span>(<span class="v">hp</span>,<span class="v">n</span>);                <span class="c">// Pozycje w kopcu</span>
  <span class="v">sptr</span> := <span class="n">0</span>;                      <span class="c">// Wska¼nik stosu</span>

  <span class="c">// Inicjujemy tablice dynamiczne</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">d</span>[<span class="v">i</span>]    := <span class="v">MAXINT</span>;
    <span class="v">p</span>[<span class="v">i</span>]    := -<span class="n">1</span>;
    <span class="v">QS</span>[<span class="v">i</span>]   := <span class="v">false</span>;
    <span class="v">graf</span>[<span class="v">i</span>] := <span class="v">nil</span>;
    <span class="v">h</span>[<span class="v">i</span>]    := <span class="v">i</span>;
    <span class="v">hp</span>[<span class="v">i</span>]   := <span class="v">i</span>;
  <span class="i">end</span>;

  <span class="v">hlen</span> := <span class="v">n</span>;

  <span class="c">// Odczytujemy dane wej¶ciowe</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">1</span> <span class="i">to</span> <span class="v">m</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">read</span>(<span class="v">x</span>,<span class="v">y</span>,<span class="v">w</span>);                  <span class="c">// Odczytujemy krawêd¼ z wag±</span>
    <span class="v">new</span>(<span class="v">pw</span>);                      <span class="c">// Tworzymy element listy s±siedztwa</span>
    <span class="v">pw</span>^.<span class="v">v</span> := <span class="v">y</span>;                   <span class="c">// Wierzcho³ek docelowy krawêdzi</span>
    <span class="v">pw</span>^.<span class="v">w</span> := <span class="v">w</span>;                   <span class="c">// Waga krawêdzi</span>
    <span class="v">pw</span>^.<span class="v">next</span> := <span class="v">graf</span>[<span class="v">x</span>];
    <span class="v">graf</span>[<span class="v">x</span>] := <span class="v">pw</span>;                <span class="c">// Element do³±czamy do listy</span>
  <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="v">d</span>[<span class="v">v</span>] := <span class="n">0</span>;                      <span class="c">// Koszt doj¶cia v jest zerowy</span>
  <span class="v">x</span> := <span class="v">h</span>[<span class="n">0</span>]; <span class="v">h</span>[<span class="n">0</span>] := <span class="v">h</span>[<span class="v">v</span>]; <span class="v">h</span>[<span class="v">v</span>] := <span class="v">x</span>; <span class="c">// odtwarzamy w³asno¶æ kopca</span>
  <span class="v">hp</span>[<span class="v">v</span>] := <span class="n">0</span>; <span class="v">hp</span>[<span class="n">0</span>] := <span class="v">v</span>;

  <span class="c">// Wyznaczamy ¶cie¿ki</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">1</span> <span class="i">to</span> <span class="v">n</span> <span class="i">do</span>
  <span class="i">begin</span>

    <span class="v">u</span> := <span class="v">h</span>[<span class="n">0</span>];                    <span class="c">// Korzeñ kopca jest zawsze najmniejszy</span>

    <span class="c">// Usuwamy korzeñ z kopca, odtwarzaj±c w³asno¶æ kopca</span>

    <span class="v">h</span>[<span class="n">0</span>] := <span class="v">h</span>[<span class="v">hlen</span> - <span class="n">1</span>];          <span class="c">// W korzeniu umieszczamy ostatni element</span>
    <span class="v">dec</span>(<span class="v">hlen</span>);                    <span class="c">// Kopiec jest krótszy o jeden element</span>
    <span class="v">hp</span>[<span class="v">h</span>[<span class="n">0</span>]] := <span class="n">0</span>;                <span class="c">// Zapamiêtujemy pozycjê elementu w kopcu</span>
    <span class="v">parent</span>   := <span class="n">0</span>;
    <span class="i">while</span> <span class="v">true</span> <span class="i">do</span>                 <span class="c">// W pêtli idziemy w dó³ kopca, przywracaj±c go</span>
    <span class="i">begin</span>
      <span class="v">left</span>  := <span class="v">parent</span> + <span class="v">parent</span> + <span class="n">1</span>; <span class="c">// Pozycja lewego potomka</span>
      <span class="v">right</span> := <span class="v">left</span> + <span class="n">1</span>;          <span class="c">// Pozycja prawego potomka</span>
      <span class="i">if</span> <span class="v">left</span> &gt;= <span class="v">hlen</span> <span class="i">then</span> <span class="v">break</span>; <span class="c">// Koñczymy, je¶li lewy potomek poza kopcem</span>
      <span class="v">dmin</span> := <span class="v">d</span>[<span class="v">h</span>[<span class="v">left</span>]];         <span class="c">// Wyznaczamy mniejszego potomka</span>
      <span class="v">pmin</span> := <span class="v">left</span>;
      <span class="i">if</span> (<span class="v">right</span> &lt; <span class="v">hlen</span>) <span class="i">and</span> (<span class="v">dmin</span> &gt; <span class="v">d</span>[<span class="v">h</span>[<span class="v">right</span>]]) <span class="i">then</span>
      <span class="i">begin</span>
        <span class="v">dmin</span> := <span class="v">d</span>[<span class="v">h</span>[<span class="v">right</span>]];
        <span class="v">pmin</span> := <span class="v">right</span>;
      <span class="i">end</span>;
      <span class="i">if</span> <span class="v">d</span>[<span class="v">h</span>[<span class="v">parent</span>]] &lt;= <span class="v">dmin</span> <span class="i">then</span> <span class="v">break</span>; <span class="c">// Je¶li w³asno¶æ kopca zachowana, koñczymy</span>
      <span class="v">x</span> := <span class="v">h</span>[<span class="v">parent</span>]; <span class="v">h</span>[<span class="v">parent</span>] := <span class="v">h</span>[<span class="v">pmin</span>]; <span class="v">h</span>[<span class="v">pmin</span>] := <span class="v">x</span>; <span class="c">// Przywracamy w³asno¶æ kopca</span>
      <span class="v">hp</span>[<span class="v">h</span>[<span class="v">parent</span>]] := <span class="v">parent</span>; <span class="v">hp</span>[<span class="v">h</span>[<span class="v">pmin</span>]] := <span class="v">pmin</span>;       <span class="c">// na danym poziomie</span>
      <span class="v">parent</span> := <span class="v">pmin</span>;             <span class="c">// i przechodzimy na poziom ni¿szy kopca</span>
    <span class="i">end</span>;

    <span class="c">// Znaleziony wierzcho³ek przenosimy do S</span>

    <span class="v">QS</span>[<span class="v">u</span>] := <span class="v">true</span>;

    <span class="c">// Modyfikujemy wszystkich s±siadów u, którzy s± w Q</span>

    <span class="v">pw</span> := <span class="v">graf</span>[<span class="v">u</span>];
    <span class="i">while</span> <span class="v">pw</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="i">if</span> <span class="i">not</span> <span class="v">QS</span>[<span class="v">pw</span>^.<span class="v">v</span>] <span class="i">and</span> (<span class="v">d</span>[<span class="v">pw</span>^.<span class="v">v</span>] &gt; <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>^.<span class="v">w</span>) <span class="i">then</span>
      <span class="i">begin</span>
        <span class="v">d</span>[<span class="v">pw</span>^.<span class="v">v</span>] := <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>^.<span class="v">w</span>;
        <span class="v">p</span>[<span class="v">pw</span>^.<span class="v">v</span>] := <span class="v">u</span>;

        <span class="c">// Po zmianie d[v] odtwarzamy w³asno¶æ kopca, id±c w górê</span>

        <span class="v">child</span> := <span class="v">hp</span>[<span class="v">pw</span>^.<span class="v">v</span>];
        <span class="i">while</span> <span class="v">child</span> &gt; <span class="n">0</span> <span class="i">do</span>
        <span class="i">begin</span>
          <span class="v">parent</span> := <span class="v">child</span> <span class="i">div</span> <span class="n">2</span>;
          <span class="i">if</span> <span class="v">d</span>[<span class="v">h</span>[<span class="v">parent</span>]] &lt;= <span class="v">d</span>[<span class="v">h</span>[<span class="v">child</span>]] <span class="i">then</span> <span class="v">break</span>;
          <span class="v">x</span> := <span class="v">h</span>[<span class="v">parent</span>]; <span class="v">h</span>[<span class="v">parent</span>] := <span class="v">h</span>[<span class="v">child</span>]; <span class="v">h</span>[<span class="v">child</span>] := <span class="v">x</span>;
          <span class="v">hp</span>[<span class="v">h</span>[<span class="v">parent</span>]] := <span class="v">parent</span>; <span class="v">hp</span>[<span class="v">h</span>[<span class="v">child</span>]] := <span class="v">child</span>;
          <span class="v">child</span> := <span class="v">parent</span>;
        <span class="i">end</span>;
      <span class="i">end</span>;
      <span class="v">pw</span> := <span class="v">pw</span>^.<span class="v">next</span>;
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="c">// Gotowe, wy¶wietlamy wyniki</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">write</span>(<span class="v">i</span>,<span class="t">': '</span>);

    <span class="c">// ¦cie¿kê przechodzimy od koñca ku pocz±tkowi,</span>
    <span class="c">// Zapisuj±c na stosie kolejne wierzcho³ki</span>

    <span class="v">j</span> := <span class="v">i</span>;
    <span class="i">while</span> <span class="v">j</span> &gt; -<span class="n">1</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">S</span>[<span class="v">sptr</span>] := <span class="v">j</span>;
      <span class="v">inc</span>(<span class="v">sptr</span>);
      <span class="v">j</span> := <span class="v">p</span>[<span class="v">j</span>];
    <span class="i">end</span>;

    <span class="c">// Wy¶wietlamy ¶cie¿kê, pobieraj±c wierzcho³ki ze stosu</span>

    <span class="i">while</span> <span class="v">sptr</span> &gt; <span class="n">0</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">dec</span>(<span class="v">sptr</span>);
      <span class="v">write</span>(<span class="v">S</span>[<span class="v">sptr</span>],<span class="t">' '</span>);
    <span class="i">end</span>;

    <span class="c">// Na koñcu ¶cie¿ki wypisujemy jej koszt</span>

    <span class="v">writeln</span>(<span class="t">'$'</span>,<span class="v">d</span>[<span class="v">i</span>]);
  <span class="i">end</span>;

  <span class="c">// Usuwamy tablice dynamiczne</span>

  <span class="v">SetLength</span>(<span class="v">d</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">p</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">QS</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">S</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">h</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">hp</span>,<span class="n">0</span>);

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">pw</span> := <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span> <span class="v">pw</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">rw</span> := <span class="v">pw</span>;
      <span class="v">pw</span> := <span class="v">pw</span>^.<span class="v">next</span>;
      <span class="v">dispose</span>(<span class="v">rw</span>);
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="n">0</span>);

<span class="i">end</span>. </pre></pre>
				</td>
			</tr>
			<tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Code::Blocks</b></td>
			</tr>
			<tr>
				<td style="text-align: left">
				<pre id="cpp"><pre><span class="c">// Algorytm Dijkstry z kolejk± priorytetow±</span>
<span class="c">// Data: 16.03.2014</span>
<span class="c">// (C)2014 mgr Jerzy Wa³aszek</span>
<span class="c">//-----------------------------------------</span>

<span class="pp">#include &lt;iostream&gt;</span>

<span class="i">using</span> <span class="i">namespace</span> <span class="v">std</span>;

<span class="c">// Typy danych</span>

<span class="i">struct</span> <span class="v">slistEl</span>
{
  <span class="v">slistEl</span> * <span class="v">next</span>;
  <span class="i">int</span> <span class="v">v</span>,<span class="v">w</span>;                        <span class="c">// numer wêz³a docelowego i waga krawêdzi</span>
};

<span class="i">const</span> <span class="i">int</span> <span class="v">MAXINT</span> = <span class="n">2147483647</span>;

<span class="c">// **********************</span>
<span class="c">// *** PROGRAM G£ÓWNY ***</span>
<span class="c">// **********************</span>

<span class="i">int</span> <span class="v">main</span>()
{
  <span class="i">int</span> <span class="v">i</span>,<span class="v">j</span>,<span class="v">m</span>,<span class="v">n</span>,<span class="v">v</span>,<span class="v">u</span>,<span class="v">w</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">sptr</span>,<span class="v">hlen</span>,<span class="v">parent</span>,<span class="v">left</span>,<span class="v">right</span>,<span class="v">dmin</span>,<span class="v">pmin</span>,<span class="v">child</span>,*<span class="v">d</span>,*<span class="v">p</span>,*<span class="v">S</span>,*<span class="v">h</span>,*<span class="v">hp</span>;
  <span class="i">bool</span> *<span class="v">QS</span>;                       <span class="c">// Zbiory Q i S</span>
  <span class="v">slistEl</span> **<span class="v">graf</span>;                 <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">slistEl</span> *<span class="v">pw</span>,*<span class="v">rw</span>;

  <span class="v">cin</span> &gt;&gt; <span class="v">v</span> &gt;&gt; <span class="v">n</span> &gt;&gt; <span class="v">m</span>;             <span class="c">// Wêze³ startowy, liczba wierzcho³ków i krawêdzi</span>

  <span class="c">// Tworzymy tablice dynamiczne</span>

  <span class="v">d</span>    = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];             <span class="c">// Tablica kosztów doj¶cia</span>
  <span class="v">p</span>    = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];             <span class="c">// Tablica poprzedników</span>
  <span class="v">QS</span>   = <span class="i">new</span> <span class="i">bool</span> [<span class="v">n</span>];            <span class="c">// Zbiory Q i S</span>
  <span class="v">graf</span> = <span class="i">new</span> <span class="v">slistEl</span> * [<span class="v">n</span>];       <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">S</span>    = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];             <span class="c">// Stos</span>
  <span class="v">h</span>    = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];             <span class="c">// Kopiec</span>
  <span class="v">hp</span>   = <span class="i">new</span> <span class="i">int</span> [<span class="v">n</span>];             <span class="c">// Pozycje w kopcu</span>
  <span class="v">sptr</span> = <span class="n">0</span>;                       <span class="c">// Wska¼nik stosu</span>

  <span class="c">// Inicjujemy tablice dynamiczne</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">d</span>[<span class="v">i</span>] = <span class="v">MAXINT</span>;
    <span class="v">p</span>[<span class="v">i</span>] = -<span class="n">1</span>;
    <span class="v">QS</span>[<span class="v">i</span>] = <span class="i">false</span>;
    <span class="v">graf</span>[<span class="v">i</span>] = <span class="v">NULL</span>;
    <span class="v">h</span>[<span class="v">i</span>] = <span class="v">hp</span>[<span class="v">i</span>] = <span class="v">i</span>;
  }

  <span class="v">hlen</span> = <span class="v">n</span>;

  <span class="c">// Odczytujemy dane wej¶ciowe</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">m</span>; <span class="v">i</span>++)
  {
    <span class="v">cin</span> &gt;&gt; <span class="v">x</span> &gt;&gt; <span class="v">y</span> &gt;&gt; <span class="v">w</span>;           <span class="c">// Odczytujemy krawêd¼ z wag±</span>
    <span class="v">pw</span> = <span class="i">new</span> <span class="v">slistEl</span>;             <span class="c">// Tworzymy element listy s±siedztwa</span>
    <span class="v">pw</span>-&gt;<span class="v">v</span> = <span class="v">y</span>;                    <span class="c">// Wierzcho³ek docelowy krawêdzi</span>
    <span class="v">pw</span>-&gt;<span class="v">w</span> = <span class="v">w</span>;                    <span class="c">// Waga krawêdzi</span>
    <span class="v">pw</span>-&gt;<span class="v">next</span> = <span class="v">graf</span>[<span class="v">x</span>];
    <span class="v">graf</span>[<span class="v">x</span>] = <span class="v">pw</span>;                 <span class="c">// Element do³±czamy do listy</span>
  }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="v">d</span>[<span class="v">v</span>] = <span class="n">0</span>;                       <span class="c">// Koszt doj¶cia v jest zerowy</span>
  <span class="v">x</span> = <span class="v">h</span>[<span class="n">0</span>]; <span class="v">h</span>[<span class="n">0</span>] = <span class="v">h</span>[<span class="v">v</span>]; <span class="v">h</span>[<span class="v">v</span>] = <span class="v">x</span>; <span class="c">// odtwarzamy w³asno¶æ kopca</span>
  <span class="v">hp</span>[<span class="v">v</span>] = <span class="n">0</span>; <span class="v">hp</span>[<span class="n">0</span>] = <span class="v">v</span>;

  <span class="c">// Wyznaczamy ¶cie¿ki</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">u</span> = <span class="v">h</span>[<span class="n">0</span>];                     <span class="c">// Korzeñ kopca jest zawsze najmniejszy</span>

    <span class="c">// Usuwamy korzeñ z kopca, odtwarzaj±c w³asno¶æ kopca</span>

    <span class="v">h</span>[<span class="n">0</span>] = <span class="v">h</span>[--<span class="v">hlen</span>];             <span class="c">// W korzeniu umieszczamy ostatni element</span>
    <span class="v">hp</span>[<span class="v">h</span>[<span class="n">0</span>]] = <span class="v">parent</span> = <span class="n">0</span>;        <span class="c">// Zapamiêtujemy pozycjê elementu w kopcu</span>
    <span class="i">while</span>(<span class="i">true</span>)                   <span class="c">// W pêtli idziemy w dó³ kopca, przywracaj±c go</span>
    {
      <span class="v">left</span>  = <span class="v">parent</span> + <span class="v">parent</span> + <span class="n">1</span>; <span class="c">// Pozycja lewego potomka</span>
      <span class="v">right</span> = <span class="v">left</span> + <span class="n">1</span>;           <span class="c">// Pozycja prawego potomka</span>
      <span class="i">if</span>(<span class="v">left</span> &gt;= <span class="v">hlen</span>) <span class="i">break</span>;     <span class="c">// Koñczymy, je¶li lewy potomek poza kopcem</span>
      <span class="v">dmin</span> = <span class="v">d</span>[<span class="v">h</span>[<span class="v">left</span>]];          <span class="c">// Wyznaczamy mniejszego potomka</span>
      <span class="v">pmin</span> = <span class="v">left</span>;
      <span class="i">if</span>((<span class="v">right</span> &lt; <span class="v">hlen</span>) &amp;&amp; (<span class="v">dmin</span> &gt; <span class="v">d</span>[<span class="v">h</span>[<span class="v">right</span>]]))
      {
        <span class="v">dmin</span> = <span class="v">d</span>[<span class="v">h</span>[<span class="v">right</span>]];
        <span class="v">pmin</span> = <span class="v">right</span>;
      }
      <span class="i">if</span>(<span class="v">d</span>[<span class="v">h</span>[<span class="v">parent</span>]] &lt;= <span class="v">dmin</span>) <span class="i">break</span>; <span class="c">// Je¶li w³asno¶æ kopca zachowana, koñczymy</span>
      <span class="v">x</span> = <span class="v">h</span>[<span class="v">parent</span>]; <span class="v">h</span>[<span class="v">parent</span>] = <span class="v">h</span>[<span class="v">pmin</span>]; <span class="v">h</span>[<span class="v">pmin</span>] = <span class="v">x</span>; <span class="c">// Przywracamy w³asno¶æ kopca</span>
      <span class="v">hp</span>[<span class="v">h</span>[<span class="v">parent</span>]] = <span class="v">parent</span>; <span class="v">hp</span>[<span class="v">h</span>[<span class="v">pmin</span>]] = <span class="v">pmin</span>;      <span class="c">// na danym poziomie</span>
      <span class="v">parent</span> = <span class="v">pmin</span>;              <span class="c">// i przechodzimy na poziom ni¿szy kopca</span>
    }

    <span class="c">// Znaleziony wierzcho³ek przenosimy do S</span>

    <span class="v">QS</span>[<span class="v">u</span>] = <span class="i">true</span>;

    <span class="c">// Modyfikujemy odpowiednio wszystkich s±siadów u, którzy s± w Q</span>

    <span class="i">for</span>(<span class="v">pw</span> = <span class="v">graf</span>[<span class="v">u</span>]; <span class="v">pw</span>; <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="v">next</span>)
      <span class="i">if</span>(!<span class="v">QS</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] &amp;&amp; (<span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] &gt; <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>))
      {
        <span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>;
        <span class="v">p</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">u</span>;

        <span class="c">// Po zmianie d[v] odtwarzamy w³asno¶æ kopca, id±c w górê</span>

        <span class="i">for</span>(<span class="v">child</span> = <span class="v">hp</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>]; <span class="v">child</span>; <span class="v">child</span> = <span class="v">parent</span>)
        {
          <span class="v">parent</span> = <span class="v">child</span> / <span class="n">2</span>;
          <span class="i">if</span>(<span class="v">d</span>[<span class="v">h</span>[<span class="v">parent</span>]] &lt;= <span class="v">d</span>[<span class="v">h</span>[<span class="v">child</span>]]) <span class="i">break</span>;
          <span class="v">x</span> = <span class="v">h</span>[<span class="v">parent</span>]; <span class="v">h</span>[<span class="v">parent</span>] = <span class="v">h</span>[<span class="v">child</span>]; <span class="v">h</span>[<span class="v">child</span>] = <span class="v">x</span>;
          <span class="v">hp</span>[<span class="v">h</span>[<span class="v">parent</span>]] = <span class="v">parent</span>; <span class="v">hp</span>[<span class="v">h</span>[<span class="v">child</span>]] = <span class="v">child</span>;
        }
      }
  }

  <span class="c">// Gotowe, wy¶wietlamy wyniki</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">cout</span> &lt;&lt; <span class="v">i</span> &lt;&lt; <span class="t">": "</span>;

    <span class="c">// ¦cie¿kê przechodzimy od koñca ku pocz±tkowi,</span>
    <span class="c">// Zapisuj±c na stosie kolejne wierzcho³ki</span>

    <span class="i">for</span>(<span class="v">j</span> = <span class="v">i</span>; <span class="v">j</span> &gt; -<span class="n">1</span>; <span class="v">j</span> = <span class="v">p</span>[<span class="v">j</span>]) <span class="v">S</span>[<span class="v">sptr</span>++] = <span class="v">j</span>;

    <span class="c">// Wy¶wietlamy ¶cie¿kê, pobieraj±c wierzcho³ki ze stosu</span>

    <span class="i">while</span>(<span class="v">sptr</span>) <span class="v">cout</span> &lt;&lt; <span class="v">S</span>[--<span class="v">sptr</span>] &lt;&lt; <span class="t">" "</span>;

    <span class="c">// Na koñcu ¶cie¿ki wypisujemy jej koszt</span>

    <span class="v">cout</span> &lt;&lt; <span class="t">"$"</span> &lt;&lt; <span class="v">d</span>[<span class="v">i</span>] &lt;&lt; <span class="v">endl</span>;
  }

  <span class="c">// Usuwamy tablice dynamiczne</span>

  <span class="i">delete</span> [] <span class="v">d</span>;
  <span class="i">delete</span> [] <span class="v">p</span>;
  <span class="i">delete</span> [] <span class="v">QS</span>;
  <span class="i">delete</span> [] <span class="v">S</span>;
  <span class="i">delete</span> [] <span class="v">h</span>;
  <span class="i">delete</span> [] <span class="v">hp</span>;

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">pw</span> = <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span>(<span class="v">pw</span>)
    {
      <span class="v">rw</span> = <span class="v">pw</span>;
      <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="v">next</span>;
      <span class="i">delete</span> <span class="v">rw</span>;
    }
  }

  <span class="i">delete</span> [] <span class="v">graf</span>;

  <span class="i">return</span> <span class="n">0</span>;
} </pre></pre>
				</td>
			</tr>
			<tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Free Basic</b></td>
			</tr>
			<tr>
				<td style="text-align: left">
				<pre id="bas"><pre><span class="c">' Algorytm Dijkstry z kolejk± priorytetow±</span>
<span class="c">' Data: 16.03.2014</span>
<span class="c">' (C)2014 mgr Jerzy Wa³aszek</span>
<span class="c">'-----------------------------------------</span>

<span class="c">' Typy danych</span>

<span class="i">Type</span> <span class="v">slistEl</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Next</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">v</span>,<span class="v">w</span>              <span class="c">' numer wêz³a docelowego i waga krawêdzi</span>
<span class="i">End</span> <span class="i">Type</span>

<span class="i">Const</span> <span class="v">MAXINT</span> = <span class="n">2147483647</span>

<span class="c">' **********************</span>
<span class="c">' *** PROGRAM G£ÓWNY ***</span>
<span class="c">' **********************</span>

<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">i</span>,<span class="v">j</span>,<span class="v">m</span>,<span class="v">n</span>,<span class="v">v</span>,<span class="v">u</span>,<span class="v">w</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">sptr</span>,<span class="v">hlen</span>,<span class="v">parent</span>,<span class="v">leftc</span>,<span class="v">rightc</span>,<span class="v">dmin</span>,<span class="v">pmin</span>,<span class="v">child</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="i">Ptr</span> <span class="v">d</span>,<span class="v">p</span>,<span class="v">S</span>,<span class="v">h</span>,<span class="v">hp</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="i">Byte</span> <span class="i">Ptr</span> <span class="v">QS</span>               <span class="c">' Zbiory Q i S</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span> <span class="v">graf</span>      <span class="c">' Tablica list s±siedztwa</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">pw</span>,<span class="v">rw</span>

<span class="i">Open</span> <span class="i">Cons</span> <span class="i">For</span> <span class="i">Input</span> <span class="i">As</span> #<span class="n">1</span>

<span class="i">Input</span> #<span class="n">1</span>,<span class="v">v</span>,<span class="v">n</span>,<span class="v">m</span>                   <span class="c">' Wêze³ startowy, liczba wierzcho³ków i krawêdzi</span>

<span class="c">' Tworzymy tablice dynamiczne</span>

<span class="v">d</span>    = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]           <span class="c">' Tablica kosztów doj¶cia</span>
<span class="v">p</span>    = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]           <span class="c">' Tablica poprzedników</span>
<span class="v">QS</span>   = <span class="i">New</span> <span class="i">Byte</span> [<span class="v">n</span>]              <span class="c">' Zbiory Q i S</span>
<span class="v">graf</span> = <span class="i">New</span> <span class="v">slistEl</span> <span class="i">Ptr</span> [<span class="v">n</span>]       <span class="c">' Tablica list s±siedztwa</span>
<span class="v">S</span>    = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]           <span class="c">' Stos</span>
<span class="v">h</span>    = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]           <span class="c">' Kopiec</span>
<span class="v">hp</span>   = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]           <span class="c">' Pozycje w kopcu</span>
<span class="v">sptr</span> = <span class="n">0</span>                         <span class="c">' Wska¼nik stosu</span>

<span class="c">' Inicjujemy tablice dynamiczne</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">d</span>[<span class="v">i</span>] = <span class="v">MAXINT</span>
  <span class="v">p</span>[<span class="v">i</span>] = -<span class="n">1</span>
  <span class="v">QS</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">graf</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">h</span>[<span class="v">i</span>] = <span class="v">i</span>
  <span class="v">hp</span>[<span class="v">i</span>] = <span class="v">i</span>
<span class="i">Next</span>

<span class="v">hlen</span> = <span class="v">n</span>

<span class="c">' Odczytujemy dane wej¶ciowe</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">m</span> - <span class="n">1</span>
  <span class="i">Input</span> #<span class="n">1</span>,<span class="v">x</span>,<span class="v">y</span>,<span class="v">w</span>                  <span class="c">' Odczytujemy krawêd¼ z wag±</span>
  <span class="v">pw</span> = <span class="i">New</span> <span class="v">slistEl</span>                <span class="c">' Tworzymy element listy s±siedztwa</span>
  <span class="v">pw</span>-&gt;<span class="v">v</span> = <span class="v">y</span>                       <span class="c">' Wierzcho³ek docelowy krawêdzi</span>
  <span class="v">pw</span>-&gt;<span class="v">w</span> = <span class="v">w</span>                       <span class="c">' Waga krawêdzi</span>
  <span class="v">pw</span>-&gt;<span class="i">Next</span> = <span class="v">graf</span>[<span class="v">x</span>]
  <span class="v">graf</span>[<span class="v">x</span>] = <span class="v">pw</span>                    <span class="c">' Element do³±czamy do listy</span>
<span class="i">Next</span>

<span class="i">Close</span> #<span class="n">1</span>

<span class="i">Print</span>

<span class="v">d</span>[<span class="v">v</span>] = <span class="n">0</span>                          <span class="c">' Koszt doj¶cia v jest zerowy</span>
<span class="i">Swap</span> <span class="v">h</span>[<span class="n">0</span>],<span class="v">h</span>[<span class="v">v</span>]                    <span class="c">' odtwarzamy w³asno¶æ kopca</span>
<span class="v">hp</span>[<span class="v">v</span>] = <span class="n">0</span>: <span class="v">hp</span>[<span class="n">0</span>] = <span class="v">v</span>

<span class="c">' Wyznaczamy ¶cie¿ki</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>

  <span class="v">u</span> = <span class="v">h</span>[<span class="n">0</span>]                        <span class="c">' Korzeñ kopca jest zawsze najmniejszy</span>

  <span class="c">' Usuwamy korzeñ z kopca, odtwarzaj±c w³asno¶æ kopca</span>

  <span class="v">hlen</span> -= <span class="n">1</span>
  <span class="v">h</span>[<span class="n">0</span>] = <span class="v">h</span>[<span class="v">hlen</span>]                  <span class="c">' W korzeniu umieszczamy ostatni element</span>
  <span class="v">hp</span>[<span class="v">h</span>[<span class="n">0</span>]] = <span class="n">0</span>                    <span class="c">' Zapamiêtujemy pozycjê elementu w kopcu</span>
  <span class="v">parent</span> = <span class="n">0</span>

  <span class="i">While</span> <span class="n">1</span>                         <span class="c">' W pêtli idziemy w dó³ kopca, przywracaj±c go</span>
    <span class="v">leftc</span>  = <span class="v">parent</span> + <span class="v">parent</span> + <span class="n">1</span>  <span class="c">' Pozycja lewego potomka</span>
    <span class="v">rightc</span> = <span class="v">leftc</span> + <span class="n">1</span>            <span class="c">' Pozycja prawego potomka</span>
    <span class="i">If</span> <span class="v">leftc</span> &gt;= <span class="v">hlen</span> <span class="i">Then</span> <span class="i">Exit</span> <span class="i">While</span> <span class="c">' Koñczymy, je¶li lewy potomek poza kopcem</span>
    <span class="v">dmin</span> = <span class="v">d</span>[<span class="v">h</span>[<span class="v">Leftc</span>]]             <span class="c">' Wyznaczamy mniejszego potomka</span>
    <span class="v">pmin</span> = <span class="v">Leftc</span>
    <span class="i">If</span> (<span class="v">rightc</span> &lt; <span class="v">hlen</span>) <span class="i">Andalso</span> (<span class="v">dmin</span> &gt; <span class="v">d</span>[<span class="v">h</span>[<span class="v">rightc</span>]]) <span class="i">Then</span>
      <span class="v">dmin</span> = <span class="v">d</span>[<span class="v">h</span>[<span class="v">rightc</span>]]
      <span class="v">pmin</span> = <span class="v">rightc</span>
    <span class="i">End</span> <span class="i">If</span>
    <span class="i">If</span> <span class="v">d</span>[<span class="v">h</span>[<span class="v">parent</span>]] &lt;= <span class="v">dmin</span> <span class="i">Then</span> <span class="i">Exit</span> <span class="i">While</span> <span class="c">' Je¶li w³asno¶æ kopca zachowana, koñczymy</span>
    <span class="i">Swap</span> <span class="v">h</span>[<span class="v">parent</span>],<span class="v">h</span>[<span class="v">pmin</span>]                     <span class="c">' Przywracamy w³asno¶æ kopca</span>
    <span class="v">hp</span>[<span class="v">h</span>[<span class="v">parent</span>]] = <span class="v">parent</span>: <span class="v">hp</span>[<span class="v">h</span>[<span class="v">pmin</span>]] = <span class="v">pmin</span> <span class="c">' na danym poziomie</span>
    <span class="v">parent</span> = <span class="v">pmin</span>                 <span class="c">' i przechodzimy na poziom ni¿szy kopca</span>
  <span class="i">Wend</span>
  
  <span class="c">' Znaleziony wierzcho³ek przenosimy do S</span>

  <span class="v">QS</span>[<span class="v">u</span>] = <span class="n">1</span>

  <span class="c">' Modyfikujemy odpowiednio wszystkich s±siadów u, którzy s± w Q</span>

  <span class="v">pw</span> = <span class="v">graf</span>[<span class="v">u</span>]
  <span class="i">While</span> <span class="v">pw</span>
    <span class="i">If</span> (<span class="v">QS</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="n">0</span>) <span class="i">Andalso</span> (<span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] &gt; <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>) <span class="i">Then</span>
      <span class="v">d</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">d</span>[<span class="v">u</span>] + <span class="v">pw</span>-&gt;<span class="v">w</span>
      <span class="v">p</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>] = <span class="v">u</span>
      
      <span class="c">' Po zmianie d[v] odtwarzamy w³asno¶æ kopca, id±c w górê</span>

      <span class="v">child</span> = <span class="v">hp</span>[<span class="v">pw</span>-&gt;<span class="v">v</span>]
      <span class="i">While</span> <span class="v">child</span> &gt; <span class="n">0</span>
        <span class="v">parent</span> = <span class="v">child</span> \ <span class="n">2</span>
        <span class="i">If</span> <span class="v">d</span>[<span class="v">h</span>[<span class="v">parent</span>]] &lt;= <span class="v">d</span>[<span class="v">h</span>[<span class="v">child</span>]] <span class="i">Then</span> <span class="i">Exit</span> <span class="i">While</span>
        <span class="i">Swap</span> <span class="v">h</span>[<span class="v">parent</span>],<span class="v">h</span>[<span class="v">child</span>]
        <span class="v">hp</span>[<span class="v">h</span>[<span class="v">parent</span>]] = <span class="v">parent</span>: <span class="v">hp</span>[<span class="v">h</span>[<span class="v">child</span>]] = <span class="v">child</span>
        <span class="v">child</span> = <span class="v">parent</span>
      <span class="i">Wend</span>
    <span class="i">End</span> <span class="i">If</span>
    <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="i">Next</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="c">' Gotowe, wy¶wietlamy wyniki</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="i">Print</span> <span class="v">i</span>;<span class="t">":"</span>;

  <span class="c">' ¦cie¿kê przechodzimy od koñca ku pocz±tkowi,</span>
  <span class="c">' Zapisuj±c na stosie kolejne wierzcho³ki</span>

  <span class="v">j</span> = <span class="v">i</span>
  <span class="i">While</span> <span class="v">j</span> &gt; -<span class="n">1</span>
    <span class="v">S</span>[<span class="v">sptr</span>] = <span class="v">j</span>
    <span class="v">sptr</span> += <span class="n">1</span>
    <span class="v">j</span> = <span class="v">p</span>[<span class="v">j</span>]
  <span class="i">Wend</span>

  <span class="c">' Wy¶wietlamy ¶cie¿kê, pobieraj±c wierzcho³ki ze stosu</span>

  <span class="i">While</span> <span class="v">sptr</span> &gt; <span class="n">0</span>
    <span class="v">sptr</span> -= <span class="n">1</span>
    <span class="i">Print</span> <span class="v">S</span>[<span class="v">sptr</span>];
  <span class="i">Wend</span>

  <span class="c">' Na koñcu ¶cie¿ki wypisujemy jej koszt</span>

  <span class="i">Print</span> <span class="i">Using</span> <span class="t">" $&amp;"</span>;<span class="v">d</span>[<span class="v">i</span>]
<span class="i">Next</span>

<span class="c">' Usuwamy tablice dynamiczne</span>

<span class="i">Delete</span> [] <span class="v">d</span>
<span class="i">Delete</span> [] <span class="v">p</span>
<span class="i">Delete</span> [] <span class="v">QS</span>
<span class="i">Delete</span> [] <span class="v">S</span>
<span class="i">Delete</span> [] <span class="v">h</span>
<span class="i">Delete</span> [] <span class="v">hp</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">pw</span> = <span class="v">graf</span>[<span class="v">i</span>]
  <span class="i">While</span> <span class="v">pw</span>
    <span class="v">rw</span> = <span class="v">pw</span>
    <span class="v">pw</span> = <span class="v">pw</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">rw</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Delete</span> [] <span class="v">graf</span>

<span class="i">End</span> </pre></pre>
				</td>
			</tr>
			<tr>
				<td style="text-align: center" bgcolor="#F0F0F0"><b>Wynik</b></td>
			</tr>
			<tr>
				<td style="text-align: left" class="program">0 6 9<br>
				0 1 3<br>
				0 4 3<br>
				1 2 1<br>
				2 3 3<br>
				2 5 1<br>
				3 1 3<br>
				4 5 2<br>
				5 0 6<br>
				5 3 1<br>
				<br>
				0: 0 $0<br>
				1: 0 1 $3<br>
				2: 0 1 2 $4<br>
				3: 0 4 5 3 $6<br>
				4: 0 4 $3<br>
				5: 0 4 5 $5</td>
			</tr>
		</tbody></table></div>

<p>&nbsp;</p>
</div>
<div class="bl1">
  
<hr size="1" color="#C0C0C0">
<br>
<div class="bl1">
  <form name="frmadminemail" action="/phpscripts/email_admin.php" method="POST" class="bs1">
    <input name="adminemail_tytul" value="Algorytmy i Struktury Danych - Algorytm Dijkstry" type="hidden">
    <div align="center">
    <h3 style="text-align: center">List do administratora Serwisu Edukacyjnego I LO</h3>
      <table style="border-collapse: collapse" border="0" cellpadding="4">
	<tbody><tr>
	  <td align="right">Twój email:</td>
	  <td><input class="respond" name="adminemail_adres" size="44" onchange="sprawdz_adres()" onkeyup="sprawdz_adres()" onkeypress="sprawdz_adres()" type="text"> <span class="t">(je¶li chcesz otrzymaæ odpowied¼)</span></td>
	</tr>
	<tr>
	  <td align="right">Temat:</td>
	  <td><input class="respond" name="adminemail_temat" size="44" onchange="sprawdz_temat()" onkeyup="sprawdz_temat()" onkeypress="sprawdz_temat()" type="text"></td>
	</tr>
	<tr>
	  <td align="right"><span class="t">Uwaga:</span></td>
	  <td><input class="respond" name="adminemail_sp" size="10" onchange="sprawdz_sp()" onkeyup="sprawdz_sp()" onkeypress="sprawdz_sp()" type="text"> <b>&#8592; tutaj wpisz wyraz 
      <span style="background-color: #FFFFFF">&nbsp;<font color="#FF0000">ilo</font> 
      </span>&nbsp;, inaczej list zostanie <span class="t">zignorowany</span></b></td>
	</tr>
      </tbody></table>
    </div>
      <p style="text-align: center" align="right">Poni¿ej wpisz swoje uwagi lub pytania dotycz±ce tego rozdzia³u <span class="rem">(max. 2048 znaków)</span>.</p>
      <p style="text-align: center" align="right"><textarea rows="10" name="adminemail_wiadomosc" cols="80" class="respond" onchange="zlicz_znaki()" onkeyup="zlicz_znaki()" onkeypress="zlicz_znaki()"></textarea></p>
      <p style="text-align: center" align="right">Liczba znaków do wykorzystania: <span id="char_count">2048</span></p>
      <p style="text-align: center" align="right"><input value="Wy¶lij" type="submit"> <input value="Kasuj" type="reset"></p>
    <input name="feedback" value="/inf/alg/001_search/0138.php" type="hidden">

<script type="text/javascript">
function zlicz_znaki()
{
   a = 2048-document.frmadminemail.adminemail_wiadomosc.value.length
   if(a < 0)
   {
      wiadomosc = document.frmadminemail.adminemail_wiadomosc.value
      wiadomosc = wiadomosc.substr(0,2048)
      document.frmadminemail.adminemail_wiadomosc.value = wiadomosc
      a = 0
   }
   document.getElementById("char_count").innerHTML = a;
}

function sprawdz_adres()
{
   if(document.frmadminemail.adminemail_adres.value.length > 128)
   {
      wiadomosc = document.frmadminemail.adminemail_adres.value
      wiadomosc = wiadomosc.substr(0,128)
      document.frmadminemail.adminemail_adres.value = wiadomosc
   }
}

function sprawdz_temat()
{
   if(document.frmadminemail.adminemail_temat.value.length > 256)
   {
      wiadomosc = document.frmadminemail.adminemail_temat.value
      wiadomosc = wiadomosc.substr(0,256)
      document.frmadminemail.adminemail_temat.value = wiadomosc
   }
}

function sprawdz_sp()
{
   if(document.frmadminemail.adminemail_sp.value.length > 3)
   {
      wiadomosc = document.frmadminemail.adminemail_sp.value
      wiadomosc = wiadomosc.substr(0,3)
      document.frmadminemail.adminemail_sp.value = wiadomosc
   }
}

</script>

  </form>
<p style="text-align: center"><b><span class="t">W zwi±zku z du¿± liczb±
 listów do naszego serwisu edukacyjnego nie bêdziemy udzielaæ odpowiedzi
 na pro¶by rozwi±zywania zadañ, pisania programów zaliczeniowych, 
przesy³ania materia³ów czy te¿ t³umaczenia zagadnieñ szeroko opisywanych
 w podrêcznikach.</span></b></p>
</div>
<br>
<hr size="1" color="#C0C0C0">
<div align="left">
  <table style="float: right; BORDER-COLLAPSE: collapse; padding-left:8px; padding-right:8px; padding-top:1px; padding-bottom:1px; cellPadding=" 4"="" border="0">
    <tbody><tr>
      <td><img src="Algorytmy%20i%20Struktury%20Danych%20-%20Algorytm%20Dijkstry_files/i-lo_budynek.jpg"></td><td valign="top"><p style="text-align: center" align="center">&nbsp;&nbsp;&nbsp;I Liceum Ogólnokszta³c±ce&nbsp;&nbsp;&nbsp;<br><span class="small">im. Kazimierza Brodziñskiego<br> w Tarnowie</span><br><span class="small">(C)2015 mgr Jerzy Wa³aszek</span></p></td>
    </tr>
  </tbody></table>
</div>
<span class="small">Dokument ten rozpowszechniany jest zgodnie z zasadami licencji<br>
<b>GNU Free Documentation License</b>.</span>
<script language="javascript">
  document.frmadminemail.adminemail_tytul.value = document.title;
</script>
<br><br><br><br><br></div>

<script type="text/javascript">pcba()</script>


</body></html>